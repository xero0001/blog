---
title: 🦕 OPERATING SYSTEM CONCEPTS - 3. 프로세스
description: 공룡책 정리하기
date: "2020-12-12S03"
tags: "운영체제"
---

# 1. 프로세스의 개념

비공식적으로 프로세스란 실행 중인 프로그램을 가르킨다. 다음과 같이 텍스트 영역, 데이터 영역, 힙 영역, 스택 영역, 자유 공간이 할당된 프로그램 이상의 개념이며 프로그램 카운터를 갖는 능동적 개체이다. 잡(Job)은 프로세스의 별칭이다.

![Process](os/process.jpg)

각 메모리 영역은 다음과 같이 구분하여 데이터를 저장한다.

- **텍스트 영역:** 실행가능한 프로그램의 코드
- **데이터 영역:** 전역 변수
- **스택 영역:** 함수 파라미터와 지역변수 등 일시적인 데이터
- **힙 영역:** 런타임에 동적 할당되는 변수

## 1.1 프로세스의 상태

프로세스는 실행되면서 그 상태가 변화한다. 각 프로세스는 다음 상태들 중 하나이다.

![Process State](os/processstate.jpg)

- **생성 (New):** 프로세스가 생성 중
- **실행 (Running):** 명령어가 실행 중
- **대기 (Waiting):** 이벤트가 일어나기를 대기중(I/O 완료와 같은 신호).
- **준비 (Ready):** CPU에 할당되기를 대기중
- **종료 (Terminated):** 프로세스가 종료됨

단 하나의 프로세스만이 하나의 코어에서 실행될 수 있으며, 다른 많은 프로세스들은 대기 혹은 준비상태에 있다.

# 1.2 프로세스 제어 블록(PCB)

프로세스 제어 블록(Process Control Block, PCB)은 특정 프로세스에 관련된 다음과같은 정보들을 저장한다.

![PCB](os/pcb.jpg)

- **프로세스 상태:** 해당 프로세스의 현재 상태(new, ready, running, waiting 등)를 가르킨다.
- **프로그램 카운터:** 해당 프로세스가 다음에 실행할 명령어의 주소를 가르킨다.
- **CPU 레지스터 백업본:** 인터럽트에서 복귀했을 때 사용한다.
- **CPU 스케쥴링 정보:** 스케쥴링에서 사용되는 매개변수의 값을 저장한다.
- **메모리 관리 정보:** 해당 프로세스가 사용중인 메모리와 페이징 정보를 저장한다.
- **통계 정보:** 해당 프로세스가 사용한 CPU, 시간, 프로세스 식별자 등을 저장한다.
- **입출력 상태 정보:** 해당 프로세스가 소유한 입출력장치 또는 파일 목록을 가르킨다.

# 1.3 쓰레드

쓰레드는 하나의 프로세스를 여러개로 나누어 실행하는 개념이다. 예를들어 쓰레드를 나눔으로써 사용자의 입력을 받으면서도 맞춤법검사를 할 수 있다. 쓰레드의 정보는 PCB에 기록된다.

# 2. 프로세스 스케줄링

멀티프로그래밍의 의의는 CPU가 쉬지 못하게 계속 일하도록 하는 것이었다. 그러면서도 시분할을 통해 유저의 입출력을 받아야한다. 이러한 동작을 위해선 프로세스 스케줄러가 실행가능한 프로세스 중 다음에 실행할 것을 전략적으로 고르는 프로세스 스케줄러가 필요하다.

## 2.1 스케줄링 큐

![Process Queue](os/processqueue.jpg)

사용자가 프로그램을 실행하면 New 상태인 프로세스가 만들어진다. 운영체제는 현재 가용할 수 있는 메모리를 확인한 뒤 해당 프로세스를 승인하면 Ready 상태로 변경된다. 이제 프로세스는 시스템 안으로 들어온 것이다. 이들은 링크드 리스트 구조로 된 큐 상에서 CPU에 할당되길 기다린다.

또 다른 큐로는 Waiting 큐가 있다. I/O 요청 등이 마치기를 기다리는 큐이다.

큐에서 자기 차례가 된 프로세스는 Running 상태가 되고, 작업이 끝나지 않은 경우엔 다시 Ready 큐에서 자기 차례를 기다린다. 모든 작업이 끝나면 Terminated 상태로 변화하며 운영체제가 종료된 프로세스에 할당했던 메모리를 회수한다.

### 2.1.1 장기 스케줄러(Long-term Scheduler)

실행이 요청되었지만 즉시 OS로부터 자원을 할당받지 못한 프로그램은 JOB Pool에서 대기한다. 이들 중 새롭게 자원을 할당받은 프로세스는 Ready Queue로 들어간다. 이러한 역할을 하는 스케줄러를 장기 스케줄러라고 한다. 잡 스케줄러라고도 부름.

### 2.1.2 단기 스케줄러(Short-term Scehduler)

Ready 큐에 들어간 프로세스 중 CPU에서 실행될 프로세스를 선택하는 스케줄러를 단기 스케줄러라고 한다. CPU 스케줄러라고도 부름.

단기스케줄러는 빈번하게 CPU가 실행할 다음 프로세스를 선택한다.

## 2.2 컨텍스트 스위칭

프로세서가 다른 프로세스로 스위치할 때, 시스템은 작업중이던 프로세스의 상태를 저장하고 새로운 프로세스의 상태를 로드해야 정보의 손실이 일어나지 않는다. 이것을 컨텍스트 스위치라고 한다. 프로세서 입장에서 컨텍스트는 PCB이기 때문에 PCB 정보가 바뀌는 것을 컨텍스트 스위치라고 하는 것이다. 컨텍스트 스위치는 오버헤드가 발생하는 작업이기 때문에 너무 자주 일어나면 성능을 저하한다.

# 3. 프로세스 연산

## 3.1 프로세스 생성

새롭게 프로세스가 생성되면 운영체제는 고유한 프로세스 식별자 (PID)를 할당하며, 이를 통해 프로세스를 구분한다. 부모 프로세스가 자식 프로세스를 생성해야 하기 때문에 트리형태로 관리된다. 시스템 콜의 fork() 함수를 호출하면 자신과 동일한 자식 프로세스를 생성하고, 이후 exec()을 통해 메모리 구조를 새로운 프로그램으로 변환한 후 실행한다. 부모 프로세스는 fork() 함수로부터 자식 프로세스의 pid를 반환받고, 자식 프로세스는 0을 반환받는다. OS는 이들 프로세스간의 통신기능을 지원한다.

## 3.2 프로세스 종료

exit()를 호출하면 프로세스를 종료시킬 수 있다. 부모 프로세스가 자식 프로세스보다 먼저 종료되면 자식 프로세스는 그 상위 프로세스를 부모 프로세스로 바라본다. 자식 프로세스가 종료되었는데, 부모 프로세스가 자식 프로세스가 반환한 정보를 회수하지 않으면 자식 프로세스는 종료되었음에도 정보가 메모리에 남아 있는 좀비 프로세스가 된다.

# 4. 프로세스간 통신(Inter Processs Communication, IPC)

프로세스는 독립적으로 동작하거나 서로 협력하며 동작할 수 있다. 협력하는 프로세스들은 통신하며 서로에게 영향을 미친다. IPC 모델에는 메시지 패싱(Message passing)과 공유 메모리(Shared memory)가 있다.

## 4.1 메시지 패싱

메시지 패싱은 우편이다. 송신 프로세스가 정보를 받는 수신 프로세스에게 커널을 통해 정보를 전달하며, 수신 프로세스도 커널에 접근해 정보를 수신한다. 메시지 패싱은 컨텍스트 스위치가 발생하기 때문에 속도가 느리다. 다만 커널이 기본적인 기능을 제공하므로 공유 메모리 방식에 비해선 구현이 쉽다.

## 4.2 공유 메모리

공유 메모리는 게시판이다. 특정 메모리 공간을 두 프로세스가 함께 사용하며 정보를 주고 받는다. 커널을 거치지 않기 때문에 속도가 빠르지만 메모리에 동시 접근하는 것을 방지하기 위해 프로그래머가 따로 구현을 해줘야 한다.

## 4.3 파이프

파이프는 부모 프로세스와 자식 프로세스가 통신할 때 사용하는 방식이다. 말 그대로 프로세스 사이에 파이프를 두고 정보를 주고 받는 건데, 파이프는 단방향 통신만 가능하기 때문에 양방향으로 정보를 주고 받으려면 두 개의 파이프가 필요하다. (파이프는 파일이다.) 파이프에 이름을 붙인 named pipe를 사용하면 꼭 부모-자식 관계가 아니더라도 파이프를 이용해 통신할 수 있다.

## 4.4 생산자-소비자 문제

협력하는 프로세스 중 정보를 생산하는 프로세스를 생산자(Producer), 정보를 소비하는 프로세스를 소비자(Consumer)라고 부른다. 생산자-소비자 문제는 두 프로세스가 동시에 동작할 때 일어나는 이슈를 말한다. 보통 정보가 생산되는 속도가 소비하는 속도보다 빠르기 때문에 동기화 문제가 발생하는데, 이를 해결하기 위해 생산된 데이터를 담아두는 버퍼(Buffer)를 사용한다. 크기에 한계가 있는 버퍼를 유한 버퍼(Bounded buffer), 버퍼의 시작과 끝을 이어붙여 크기가 무한한 버퍼를 무한 버퍼(Unbounded buffer)라고 한다.

## 4.5 동기화

메시지 패싱의 동기화 문제를 해결하기 위해 blocking 방식과 non-blocking 방식이 사용된다.

- **Blocking send:** 수신자가 메시지를 받을 때까지 송신자는 block된다.
- **Blocking receive:** 메시지를 수신할 때까지 수신자는 block된다.
- **Non-blocking send:** 송신자가 메시지를 보내고 작업을 계속한다.
- **None-blocking receive:** 수신자가 유효한 메시지나 Null 메시지를 받는다.

# 5. 소켓

소켓은 서버와 클라이언트가 통신하는 방식이다. 소켓은 통신의 엔드 포인트를 의미하고, 두 소켓을 연결하여 하나의 채널로 취급한다. IP주소와 포트 정보가 있으면 클라이언트는 네트워크를 통해 서버 프로세스에 접근할 수 있다. RPC(Remote Procedure Calls)는 프로세스와 프로세스가 네트워크로 이어져 있을 때 발생하는 호출을 말한다. 서버와 클라이언트가 통신할 때는 IP주소와 포트를 래핑해서 Stub으로 만들어 전송한다.

# References

[🦕 공룡책으로 정리하는 운영체제 Ch.3 (parksb.github.io) - 9판](https://parksb.github.io/article/7.html)

[운영체제 정리 🦖 ch03. 프로세스](https://aerocode.net/372?category=798030)
