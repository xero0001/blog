---
title: 💻 C++ 개인 정리 2 (C++ 11/14/17)
description: 개인적으로 부족한 부분만 정리한 C++ 노트
tags: "C++"
date: "2020-12-20S02"
---

# C++ 11 ~

## auto

## static_assert

assert는 실행 중에 평가하기 때문에 static_assert를 쓰는게 좋다. static_assert는 컴파일 때 평가함.

## default, delete

default는 컴파일러가 특정한 생성자, 연산자 및 소멸자를 만들어 낼 수 있음. 비어있는 생성자나 소멸자를 구체화할 필요 없다.

default는 빈 생성자를 만들어줌.

delete는 사용하지 못하게 만들어줌. 다음 예에서 복사 생성자를 사용하지 못하게함.

```cpp
// Dog.h
class Dog
{
public:
  Dog() = default;
  Dog(std::string name);
  Dog(const Dog& other) = delete;
private:
  std::string mName;
}
```

## final, override

final로 상속 막기.

override로 오버라이딩 명시화.

## nullptr

NULL 쓰지말고 nullptr 씁시다.

# 유니크 포인터

원시 포인터를 단독으로 소유하고, 누구하고도 공유하지 않음.

따라서 복사나 대입이 불가하다.

scope를 벗어날 때 자동으로 delete됨.

```cpp
int main()
{
  // Vector* myVector = new Vector(10.f, 30.f);
  std::unique_ptr<Vector> myVector(new Vector(10.f, 30.f));

  myVector->Print();

  // delete myVector
  return 0;
}
```

```cpp
std::unique_ptr<Vector> myVector(new Vector(10.f, 30.f));

std::unique_ptr<Vector> copiedVector1 = myVector; // 컴파일 에러
std::unique_ptr<Vector> compiedVector2(myVector); // 컴파일 에러
```

옛날에 벡터에 포인터 저장시

```cpp
int main()
{
  std::vector<Player*> players;

  players.push_back(new Player("Lulu"));
  players.push_back(new Player("Coco"));

  for (int i=0; i<players.size(); ++i)
  {
    delete players[i];
  }

  players.clear();
}
```

유니크 포인터는 자동으로 삭제해줌.

```cpp
int main()
{
  std::vector<std::unique_ptr<Player>> playerList;

  playerList.push_back(std::unique_ptr<Player>(new Player("Lulu")));
  playerList.push_back(std::unique_ptr<Player>(new Player("Coco")));

  // 클리어하면서 다 지워줌
  playerList.clear();

  // 안해줘도 스코프 나가면서 삭제됨
}
```

# References

https://www.learncpp.com/
