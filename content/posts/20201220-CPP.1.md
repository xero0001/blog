---
title: ğŸ’» C++ ê°œì¸ ì •ë¦¬ 1
description: ê°œì¸ì ìœ¼ë¡œ ë¶€ì¡±í•œ ë¶€ë¶„ë§Œ ì •ë¦¬í•œ C++ ë…¸íŠ¸
tags: "C++"
date: "2020-12-20S01"
---

# ê¸°ë³¸ ìë£Œí˜•

ìë£Œí˜•ì˜ ì¹´í…Œê³ ë¦¬ì™€ ìë£Œí˜•, ê·¸ë¦¬ê³  ê´„í˜¸ ì•ˆì—ëŠ” ì‚¬ì´ì¦ˆë¥¼ ì ì–´ë†“ì•˜ë‹¤.
ì—¬ê¸°ì„œ ì‚¬ì´ì¦ˆëŠ” ì•„í‚¤í…ì³ì™€ ì»´íŒŒì¼ëŸ¬ë§ˆë‹¤ ë‹¤ë¥´ê²Œ ì„¤ì •ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì¼ë°˜ì ì¸ í¬ê¸°ë¥¼ ë§í•œë‹¤.

- boolean: bool(1)
- character: char(1), wchar_t(2), char16_t(2), char32_t(4)
- floating point: float(4), double(8), long double(8)
- integer: short(2), int(4), long(4)
- void: no type

sizeof(bool), sizeof(int) ì™€ ê°™ì€ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ ë³€ìˆ˜ì˜ í¬ê¸°ë¥¼ ì•Œ ìˆ˜ ìˆë‹¤.

## size_t

## char

ë¬¸ìì—´ ê¸¸ì´ë³´ë‹¤ í•˜ë‚˜ ë” ë§ê²Œ ì„¤ì •í•´ì•¼ /EOFê¹Œì§€ í¬í•¨í•œë‹¤.

# ë¦¬í„°ëŸ´ê³¼ ìƒìˆ˜, constexpr

## ë¦¬í„°ëŸ´

ì§ì ‘ ìˆ«ìë¥¼ ì ì–´ë„£ëŠ”ê²ƒ.

```cpp
int force = mass * 9.8;
```

### ë°”ì´ë„ˆë¦¬ ë¦¬í„°ëŸ´

```cpp
const unsigned char option0 = 0b0000'0001;
```

### 16ì§„ìˆ˜ ë¦¬í„°ëŸ´

```cpp
const unsigned char option0 = 0x1;

// 4ë°”ì´íŠ¸
const unsigned int redBits = 0xFF000000;
```

### STL ë¹„íŠ¸ í”Œë˜ê·¸ ì¡°ì‘

```cpp
#include <bitset>

std::bitset<8> bits;
```

## ìƒìˆ˜

constë¡œ í•œë²ˆ ì„ ì–¸í•˜ë©´ ë³€ê²½í•  ìˆ˜ ì—†ë‹¤. ë¦¬í„°ëŸ´ì²˜ëŸ¼ ì‚¬ìš©ëœë‹¤.

```cpp
const double gravity {9.8};
int const edgesInSquare {4};
```

## constexpr

ì»´íŒŒì¼ íƒ€ì„ì— í‘œí˜„ì‹ìœ¼ë¡œë¶€í„° ìƒìˆ˜ë¥¼ ë§Œë“¤ì–´ì¤€ë‹¤.

```cpp
constexpr double gravity(9.8);
constexpr int sum = 4+5;
```

## ë³€ìˆ˜ ì´ˆê¸°í™”

### ë³µì‚¬ ì´ˆê¸°í™”

```cpp
int nValue=5;
```

### ì§ì ‘ ì´ˆê¸°í™”

```cpp
int nValue(5);
```

### ìœ ë‹ˆí¼ ì´ˆê¸°í™” (C++ 11)

ëª¨ë“  ë°ì´í„°íƒ€ì…ì— ì‘ë™í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜. í˜• ë³€í™˜ì„ í—ˆìš©í•˜ì§€ ì•Šì•„ì„œ ì—ëŸ¬ë¥¼ ë„ì›Œì¤Œ.

```cpp
int value{5};
int nValue{4.5}; // error
```

## size_t

# í—¤ë” ê°€ë“œ

ì—¬ëŸ¬ íŒŒì¼ì— dependencyê°€ ìˆëŠ” í—¤ë” íŒŒì¼ì˜ ê²½ìš°, ì¤‘ë³µí•´ì„œ includeí•˜ë©´ ì»´íŒŒì¼ ì—ëŸ¬ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.

```cpp
#ifndef MATH_H
#define MATH_H
```

í˜¹ì€

```cpp
#pragma once
```

ë¥¼ ì´ìš©í•´ í—¤ë” ê°€ë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

# Undefined Behaviour

ì‚¬ëŒì´ ë´ë„ í—·ê°ˆë¦´ë§Œí•œ ëª…ë ¹ì€ ì‚¬ìš©í•˜ì§€ ë§ì. ì»´íŒŒì¼ëŸ¬ì—ì„œ UBë¡œ ì¡ì•„ì£¼ê¸´ í•œë‹¤.

```cpp
x = x++;
```

# ìŠ¤ì½”í”„

## extern

externì€ ì™¸ë¶€ ë§í¬ê°€ ìˆëŠ” ë³€ìˆ˜ë¥¼ ì˜ë¯¸í•œë‹¤.

externì€ ì™¸ë¶€ ë§í¬ë¥¼ í¬í•¨í•˜ì—¬ ë‹¤ë¥¸ ì†ŒìŠ¤ íŒŒì¼ì—ì„œë„ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤.

ë‹¤ë¥¸ ì˜ë¯¸ë¡œëŠ” ë‹¤ë¥¸ ì–´ë”˜ê°€ì—ì„œ ê°€ì ¸ì˜¨ ë³€ìˆ˜ì— ëŒ€í•œ ì „ë°© ì„ ì–¸ì„ ì˜ë¯¸í•˜ê¸°ë„ í•œë‹¤.

ë§Œì•½ ë‹¤ë¥¸ ì†ŒìŠ¤ì—ì„œ ê°€ì ¸ì˜¨ ë³€ìˆ˜ì— ëŒ€í•œ ì „ë°© ì„ ì–¸ì¸ ê²½ìš° ì„ ì–¸ëœ ë¸”ë¡ì—ì„œë§Œ í•´ë‹¹ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

## Static

Staticì€ ì „ì—­ë³€ìˆ˜ì™€ ë¹„ìŠ·í•˜ì§€ë§Œ, í•´ë‹¹ ë¸”ë¡ ë‚´ì—ì„œë§Œ ì‚¬ìš©ê°€ëŠ¥í•œ ë³€ìˆ˜ë¼ê³  í•  ìˆ˜ ìˆë‹¤. staticì€ ë‚´ë¶€ ë§í¬ë§Œ ìˆë‹¤.

ì „ì—­ ë³€ìˆ˜ëŒ€ì‹  staticì„ ì“°ëŠ”ê²ƒì´ ì‹¤ìˆ˜í•  ê°€ëŠ¥ì„±ë„ ë‚®ê³  ì¢‹ë‹¤.

## Duration

ì¼ë°˜ ì§€ì—­ ë³€ìˆ˜ëŠ” ìŠ¤íƒì— ì €ì¥ë˜ì—ˆë‹¤ê°€ ë¸”ë¡ì´ ëë‚˜ë©´ ì‚¬ë¼ì§. ì´ë¥¼ automatic durationì´ë¼ í•¨.

global, static variablesëŠ” í”„ë¡œê·¸ë¨ì´ ì‹œì‘ë  ë•Œ ìƒì„±ë˜ê³ , ì¢…ë£Œë  ë•Œ ì‚¬ë¼ì§. static durationì´ë¼ í•¨. ë©”ëª¨ë¦¬ì˜ ë°ì´í„° ë¶€ë¶„ì— ì €ì¥ë¨.

ë™ì í• ë‹¹ëœ ë³€ìˆ˜ë§Œì´ í”„ë¡œê·¸ë˜ë¨¸ì˜ ìš”ì²­ì— ì˜í•´ ìƒì„±ë˜ì—ˆë‹¤ê°€ ì‚¬ë¼ì§. í™ì— ì €ì¥ë¨.

# ìºìŠ¤íŒ…

## static_cast

ê°€ì¥ ì•ˆì „í•˜ê²Œ ìºìŠ¤íŒ…í•˜ëŠ” ë°©ë²•. ì˜¤ë¥˜ ë°œìƒí•  ì¼ì´ ê±°ì˜ ì—†ë‹¤.

```cpp
char c = 'a';
std::cout << static_cast<int>(c) << std::endl; // 97ì„ í”„ë¦°íŠ¸í•œë‹¤.
```

# enum

```cpp
enum Animal
{
  ANIMAL_CAT = -3,
  ANIMAL_DOG, // -2
  ANIMAL_PIG, // -1
  ANIMAL_HORSE = 5,
  ANIMAL_GIRAFFE = 5,
  ANIMAL_CHICKEN // 6
}

Animal animal(ANIMAL_CAT);
```

## enum class

ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš° classë¥¼ ì“°ì§€ ì•Šìœ¼ë©´ ì»´íŒŒì¼ ì—ëŸ¬ê°€ ëœ¨ì§€ ì•ŠëŠ”ë‹¤.

```cpp
#include <iostream>
int main()
{
  enum class Color // "enum class" defines this as a scoped enumeration instead of a standard enumeration
  {
    RED, // RED is inside the scope of Color
    BLUE
  };

  enum class Fruit
  {
    BANANA, // BANANA is inside the scope of Fruit
    APPLE
  };

  Color color = Color::RED; // note: RED is not directly accessible any more, we have to use Color::RED
  Fruit fruit = Fruit::BANANA; // note: BANANA is not directly accessible any more, we have to use Fruit::BANANA

  if (color == fruit) // compile error here, as the compiler doesn't know how to compare different types Color and Fruit
    std::cout << "color and fruit are equal\n";
  else
    std::cout << "color and fruit are not equal\n";

  return 0;
}
```

# typedef

ë©€í‹° í”Œë«í¼ ê°œë°œì„ ìœ„í•´ì„œë‚˜, ê°€ë…ì„±ì„ ìœ„í•´ì„œ íƒ€ì… ì´ë¦„ì— ë³„ëª…ì„ ë¶™ì¼ ìˆ˜ ìˆë‹¤.

```cpp
typedef double distance_t; // define distance_t as an alias for type double
```

## C++ 11

```cpp
using distance_t = double; // define distance_t as an alias for type double
```

# êµ¬ì¡°ì²´

ë¹„ ì •ì  ë©¤ë²„ ë³€ìˆ˜ì— ëŒ€í•´ì„œëŠ” ì§ì ‘ ê¸°ë³¸ê°’ì„ ì§€ì •í•  ìˆ˜ ìˆë‹¤.

```cpp
struct Rectangle
{
  double length = 1.0;
  double width = 1.0;
};

int main()
{
  Rectangle x; // length = 1.0, width = 1.0

  x.length = 2.0; // you can assign other values like normal

  return 0;
}
```

ê·¸ëŸ¬ë‚˜ ì•„ë˜ Rectangleì—ì„œ

```cpp
  Rectangle x{ 2.0, 2.0 };
```

ìœ„ì™€ ê°™ì´ ì´ˆê¸°í™”í•˜ëŠ” ê²ƒê³¼ëŠ” í•¨ê»˜ ì‚¬ìš©í•  ìˆ˜ëŠ” ì—†ë‹¤.

# auto íƒ€ì… ì¶”ë¡ 

C++ 11ì—ì„œ ë³€ìˆ˜ë¥¼ ìœ„í•œ íƒ€ì… ì¶”ë¡ ì´ ë“±ì¥.

C++ 14ì—ì„œëŠ” í•¨ìˆ˜ë¥¼ ìœ„í•œ íƒ€ì… ì¶”ë¡ ì´ ë“±ì¥.

ëª¨ë‘ ì»´íŒŒì¼ íƒ€ì„ì— ê²°ì •ëœë‹¤.

# í¬ì¸í„° ë° ì°¸ì¡°

## ì°¸ì¡°(Reference)

ë§¤ê°œë³€ìˆ˜ ì „ë‹¬ ì‹œ í¬ì¸í„°ë³´ë‹¤ ì¢€ ë” ì•ˆì „í•˜ë‹¤.

ì°¸ì¡°ë€ ì¼ì¢…ì˜ ë³„ì¹­ì´ë‹¤. NULLì´ ë  ìˆ˜ ì—†ìœ¼ë©°, ì´ˆê¸°í™” ì¤‘ì— ë°˜ë“œì‹œ ì„ ì–¸ë˜ì–´ì•¼ë§Œ í•œë‹¤.

```cpp
int number = 100;
int& reference = number;
```

ì´í›„ ì°¸ì¡°í•˜ëŠ” ëŒ€ìƒì„ ë°”ê¿€ ìˆ˜ ì—†ë‹¤.

```cpp
int number1 = 100;
int number2 = 200;

int& reference = number1;
reference = number2; // ì„¸ ë³€ìˆ˜ ê°’ì´ ëª¨ë‘ 200ì´ ë¨.
```

### ê°’ì— ì˜í•œ í˜¸ì¶œ

```cpp
void swap(int arg1, int arg2)
{
  int temp = arg1;
  arg1 = arg2;
  arg2 = temp;
}

int main()
{
  int num1 = 10;
  int num2 = 10;

  swap(num1, num2);
  // ...
}
```

### ì°¸ì¡°ì— ì˜í•œ í˜¸ì¶œ

#### í¬ì¸í„°ë¡œ

í¬ì¸í„°ë¡œ í•˜ë©´ `*(arg1+1)` ê³¼ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ë‹¤ë¥¸ ë³€ìˆ˜ë¥¼ ê±´ë“œë¦¬ëŠ” í–‰ìœ„ë¥¼ í•  ìœ„í—˜ì´ ìˆë‹¤.

```cpp
void swap(int* arg1, int* arg2)
{
  int temp = *arg1;
  *arg1 = *arg2;
  *arg2 = temp;
}

int main()
{
  int num1 = 10;
  int num2 = 20;

  swap(&num1, &num2);
  // ...
}
```

#### ì°¸ì¡°ë¡œ

ìˆœìˆ˜í•˜ê²Œ ì°¸ì¡°ë¡œ í•˜ë©´ ìœ„í—˜ì´ ìƒê¸°ì§€ ì•ŠëŠ”ë‹¤. ì°¸ì¡°ëŠ” ê°€ë¦¬í‚¤ëŠ” ëŒ€ìƒì„ ë³€ê²½í•  ìˆ˜ ì—†ëŠ”, ë³„ì¹­ì´ê¸° ë•Œë¬¸ì´ë‹¤.

```cpp
void swap(int& arg1, int& arg2)
{
  int temp = arg1;
  arg2 = arg1;
  arg2 = temp;
}

int main()
{
  int num1 = 10;
  int num2 = 20;

  swap(num1, num2);
  // ...
}
```

ë°°ì—´ì€ ë‹¤ìŒê³¼ ê°™ì´ ê¸¸ì´ë¥¼ ëª…ì‹œí•´ì•¼ í•œë‹¤.

```cpp
#include <iostream>

// Note: You need to specify the array size in the function declaration
void printElements(int (&arr)[4])
{
  int length{ sizeof(arr) / sizeof(arr[0]) }; // we can now do this since the array won't decay
  for (int i{ 0 }; i < length; ++i)
  {
    std::cout << arr[i] << std::endl;
  }
};

int main()
{
  int arr[]{ 99, 20, 14, 80 };

  printElements(arr);

  return 0;
};
```

```cpp
void foo(int x[]);
```

ì™€ ê°™ì´ ì„ ì–¸í•´ë„ ë¬¸ì œëŠ” ì—†ë‹¤. ë‹¤ë§Œ ë°°ì—´ì˜ ì‚¬ì´ì¦ˆë¥¼ ì•Œ ìˆ˜ê°€ ì—†ë‹¤. ë‹¤ìŒì²˜ëŸ¼ë„ ì‚¬ìš© ê°€ëŠ¥í•˜ë‹¤. ì´ëŠ”

```cpp
void foo(int *(&arr));
```

í¬ì¸í„°ë¥¼ ì‚¬ìš©í•˜ë©´ ë‹¤ìŒê³¼ê°™ë‹¤.

```cpp
void foo(int* x);
```

## malloc/free ì™€ new/deleteì˜ ì°¨ì´ì 

malloc/free ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ êµ¬í˜„í•´ ì£¼ëŠ” ê²ƒì´ê³ ,

new/delete ëŠ” ì–¸ì–´ì—ì„œ êµ¬í˜„í•´ì£¼ëŠ” ê²ƒì´ë‹¤.

mallocì€ ì¬í• ë‹¹ì´ ê°€ëŠ¥í•˜ê³ , newëŠ” ì¬í• ë‹¹ì´ ë¶ˆê°€ëŠ¥í•˜ë‹¤.

newë¡œ ì¬í• ë‹¹í•˜ë ¤ë©´ ë‹¤ìŒì²˜ëŸ¼ í•´ì£¼ì–´ì•¼í•œë‹¤.

```cpp
int value = 5;
int* ptr = new int; // allocate memory
delete ptr; // return memory back to operating system
ptr = &value; // reassign pointer to address of value
```

## null pointer

ì˜¤ë²„ë¡œë”©ëœ ë©”ì„œë“œë¥¼ ë¶€ë¥¼ ë•Œ `NULL` ê°’ì„ ì¸ìë¡œ ì „ë‹¬í•˜ë©´ ì´ê²ƒì´ ìƒìˆ˜ì¸ì§€, í¬ì¸í„°ì¸ì§€ ì•Œ ìˆ˜ ì—†ì–´ ë¬¸ì œë¥¼ ì¼ìœ¼í‚¨ë‹¤. NULLì€ ê·¸ì € `0`ì¼ ë¿ì´ê¸° ë•Œë¬¸ì´ë‹¤.

ë„ í¬ì¸í„°ëŠ” í¬ì¸í„°ì„ì„ í™•ì‹¤íˆ ì•Œë¦¬ëŠ” ìë£Œí˜•ì´ë‹¤.

ì™ ë§Œí•˜ë©´ nullptrì„ ì“°ì.

```cpp
char* ch = nullptr;
```

## void pointer

ëª¨ë“  ë°ì´í„°íƒ€ì…ì„ ê°€ë¦¬í‚¬ ìˆ˜ ìˆëŠ” í¬ì¸í„°ì´ë‹¤.

```cpp
int nValue;
float fValue;
struct Something
{
  int n;
  float f;
};

Something sValue;

void* ptr;
ptr = &nValue; // valid
ptr = &fValue; // valid
ptr = &sValue; // valid
```

ê·¸ëŸ¬ë‚˜ ì´ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ëª…ì‹œì  ë³€í™˜í•´ì•¼í•œë‹¤.

```cpp
int value = 5;
void* voidPtr = &value;

//cout << *voidPtr << endl; // illegal: cannot dereference a void pointer

int* intPtr = static_cast<int*>(voidPtr); // however, if we cast our void pointer to an int pointer...

cout << *intPtr << endl; // then we can dereference it like normal

// 5
```

## ë™ì  ë°°ì—´ í• ë‹¹

`new[]`ì™€ `delete[]` ì—°ì‚°ìë¥¼ ì‚¬ìš©í•´ í• ë‹¹í•˜ê³  í•´ì œí•  ìˆ˜ ìˆë‹¤.

```cpp
#include <iostream>

int main()
{
  int length;
  std::cin >> length;

  int *arr = new int[length];

  array[0]=5;

  delete[] array;

  return 0;
};
```

### C++ 11

0ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ëŠ” ë²•ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

```cpp
int* array = new int[length]();
```

ì´ˆê¸°í™” ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.

```cpp
int* array = new int[5] { 5, 2, 5, 1, 6 };
```

# í•¨ìˆ˜

## const ë©¤ë²„í•¨ìˆ˜

ë©¤ë²„ ë³€ìˆ˜ë¥¼ ë°”ê¾¸ì§€ ì•ŠëŠ” ì½ê¸°ì „ìš©ê°™ì€ í•¨ìˆ˜.

```cpp
int GetX() const
{
  return mX;
};

void AddConst(const Vector& other) const
{
  mX = mX + other.mX; // ì»´íŒŒì¼ ì—ëŸ¬
  mY = mY + other.mY; // ì»´íŒŒì¼ ì—ëŸ¬
};
```

## ì¸ë¼ì¸ í•¨ìˆ˜

í•¨ìˆ˜ë¥¼ ì½œí•˜ëŠ” í–‰ìœ„ëŠ” í•¨ìˆ˜ í¬ì¸í„°ë¥¼ ì°¾ì•„ ì‹¤í–‰í•˜ê³ , ìŠ¤íƒì— íŒŒë¼ë¯¸í„°ë¥¼ ì˜¬ë¦¬ëŠ” ë“± ë°”ë¡œ ì‹¤í–‰í•˜ëŠ” ê²ƒì— ë¹„í•´ ë¹„ì‹¼ ì‘ì—…ì´ë‹¤.

ê·¸ë ‡ë‹¤ê³  ë°”ë¡œ ì½”ë“œë¥¼ ì“°ëŠ”ê²ƒë³´ë‹¤ëŠ” ë¦¬íŒ©í† ë§ì´ ê°€ëŠ¥í•˜ê²Œ í•˜ê¸°ìœ„í•´ ì¸ë¼ì¸ í•¨ìˆ˜ë¥¼ ì“¸ ìˆ˜ ìˆë‹¤. ì¸ë¼ì¸ í•¨ìˆ˜ëŠ” í•¨ìˆ˜ì˜ ì‹¤í–‰ë‚´ìš©ì„ ì½”ë“œì— ë³µì‚¬í•´ì£¼ë¯€ë¡œ ì‹¤ì œë¡œ í•¨ìˆ˜ë¥¼ ì½œ í•˜ëŠ”ê²ƒì´ ì•„ë‹ˆë‹¤.

```cpp
// ì»´íŒŒì¼ ì „
inline int Square(int number)
{
  return number * number;
}

int main()
{
  int number = 2;
  int result = Square(number);
  return 0;
}

// ì»´íŒŒì¼ ì´í›„
int main()
{
  int number = 2;
  int result = number * number;
  return 0;
}
```

ì¸ë¼ì¸ í•¨ìˆ˜ëŠ” í‚¤ì›Œë“œë¥¼ ë¶™ì¸ë‹¤ê³  ë¬´ì¡°ê±´ ì¸ë¼ì¸ì´ ë˜ì§€ëŠ” ì•Šì„ ìˆ˜ ìˆë‹¤. ì»´íŒŒì¼ëŸ¬ê°€ ì´ê²ƒì„ íŒë‹¨í•œë‹¤.

ë˜í•œ ì¸ë¼ì¸ í•¨ìˆ˜ êµ¬í˜„ì€ í—¤ë” íŒŒì¼ì— ìœ„ì¹˜í•´ì•¼ í•œë‹¤.

ë¬´ì¡°ê±´ ì„±ëŠ¥ì´ ì¢‹ì•„ì§€ëŠ”ì§€ëŠ” ì•Œ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ getterë‚˜ setter ìˆ˜ì¤€ì˜ ê°„ë‹¨í•œ í•¨ìˆ˜ì— ì í•©í•˜ë‹¤.

ë‚¨ìš©í•˜ì§€ ë§ì! ì‹¤í–‰íŒŒì¼ì˜ í¬ê¸°ê°€ ì¦ê°€í•  ìˆ˜ë„ ìˆë‹¤.

## ì •ì  í•¨ìˆ˜

í•´ë‹¹ í´ë˜ìŠ¤ì˜ ì •ì  ë©¤ë²„ì—ë§Œ ì ‘ê·¼ ê°€ëŠ¥. ê°œì²´ê°€ ì—†ì–´ë„ ì •ì  í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆìŒ.

```cpp
Math::Square(10);
```

## í…œí”Œë¦¿

Javaì™€ C#ì˜ genericê³¼ ë¹„ìŠ·í•˜ë‹¤. ê·¸ëŸ¬ë‚˜ ì´ë“¤ì€ ëŸ°íƒ€ì„ì—ë§Œ í•´ì¤€ë‹¤.

STL ì»¨í…Œì´ë„ˆ ë˜í•œ í…œí”Œë¦¿ì´ë‹¤.

ì½”ë“œë¥¼ ìë£Œí˜•ë§ˆë‹¤ ì¤‘ë³µìœ¼ë¡œ ì‘ì„±í•˜ì§€ ì•Šì•„ë„ ë˜ê³ , ì»´íŒŒì¼ëŸ¬ê°€ ì´ë¥¼ ì»´íŒŒì¼ íƒ€ì„ì— ì²˜ë¦¬í•´ì„œ ë¹ ë¥´ê²Œ ë§Œë“¤ì–´ ì¤„ ìˆ˜ ìˆë‹¤.

ë‹¤í˜•ì„±ë³´ë‹¤ ë¹¨ë¼ì§ˆ ìˆ˜ ìˆë‹¤!

```cpp
// MyMath.h
int Add(int a, int b)
{
  return a + b;
}

// Main.cpp
#include "MyMath.h"
#include <iostream>

int main()
{
  std::cout << Add(3,10) << std::endl;

  return 0;
}
```

```cpp
// MyMath.h
template <typename T> // ë˜ëŠ” template <class T>
T Add(T a, T b)
{
  return a + b;
}

// Main.cpp
#include "MyMath.h"

int main()
{
  // <typename> ì€ ìƒëµ ê°€ëŠ¥
  std::cout << Add<int>(3, 10) << std::endl;
  std::cout << Add<float>(3.14f, 10.14f) << std::endl;

  return 0;
}
```

ê·¸ëŸ¬ë‚˜ í…œí”Œë¦¿ì— ë„£ëŠ” ìë£Œí˜• ê°€ì§“ìˆ˜ì— ë¹„ë¡€í•´ì„œ exe íŒŒì¼ì˜ í¬ê¸°ê°€ ì¦ê°€í•œë‹¤.

## í´ë˜ìŠ¤ í…œí”Œë¦¿

êµ¬í˜„ë¶€ë„ ê°™ì€ í—¤ë”íŒŒì¼ ì•ˆì— í¬í•¨ì‹œì¼œì£¼ì.

```cpp
// MyArray.h
#pragma once
template<typename T>
class MyArray
{
public:
  bool Add(T data);
  MyArray();
private:
  enum { MAX = 3 };
  int mSize;
  T mArray[MAX];
}

// MyArray.cpp
#include "MyArray.h"

template<typename T>
bool MyArray<T>::Add(T data)
{
  if (mSize >= MAX)
  {
    return false;
  }
  mArray[mSize++] = data;
  return true;
}

template<typename T>
MyArray<T>::MyArray()
  : mSize(0)
{
}

// Main.cpp
#include "MyArray.h"

int main()
{
  MyArray<int> scores;

  scores.Add(10); // true ë°˜í™˜
  scores.Add(20); // true ë°˜í™˜
  scores.Add(30); // true ë°˜í™˜
  scores.Add(40); // false ë°˜í™˜

  return 0;
}
```

### í´ë˜ìŠ¤ í…œí”Œë¦¿ íŠ¸ë¦­

ì¬í• ë‹¹ë˜ì§€ ì•ŠëŠ” ë²¡í„°ë¥¼ ë§Œë“œëŠ” ë°©ë²•.

í…œí”Œë¦¿ ë§¤ê°œë³€ìˆ˜ì— typenameë¿ ì•„ë‹ˆë¼ ë‹¤ë¥¸ ê±¸ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.

```cpp
// FixedVector.h

template<typename T, size_t N>
class FixedVector
{
public:
  // public methods
private:
  T mArray[N];
}

// main.cpp
FixedVector<int, 16> numbers;
```

```cpp
template<typename T, typename U>
MyPair<T, U>::MyPair(const T& first, const U& second)
  : mFirst(first)
  , mSecond(second)
{
}
```

### í…œí”Œë¦¿ íŠ¹ìˆ˜í™”

íŠ¹ì •í•œ í…œí”Œë¦¿ ë§¤ê°œë³€ìˆ˜ë¥¼ ë°›ë„ë¡ í…œí”Œë¦¿ ì½”ë“œë¥¼ ì»¤ìŠ¤í„°ë§ˆì´ì¦ˆ í•  ìˆ˜ ìˆìŒ.

ìì£¼ ì‚¬ìš©ë˜ì§„ ì•Šì§€ë§Œ, ë©”ëª¨ë¦¬ê°€ ìª¼ë“¤ë¦°ë‹¤ë©´ ì‚¬ìš©í•  ê°€ì¹˜ê°€ ìˆìŒ.

```cpp
template <class T, class Allocator>
class std::vector<T, Allocator> {} // ëª¨ë“  í˜•ì„ ë°›ëŠ” ì œë„¤ë¦­ vector

template <class Allocator>
class std::vector<bool, Allocator> // boolì„ ë°›ë„ë¡ íŠ¹ìˆ˜í™”ëœ vector
```

í•„ìš”í•  ë•Œ ì°¾ì•„ë³´ì.

# OOP

## ì ‘ê·¼ ì œì–´ì

- public: ëˆ„êµ¬ë‚˜ ì ‘ê·¼ ê°€ëŠ¥
- protected: ìì‹ í´ë˜ìŠ¤ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥
- private: í•´ë‹¹ í´ë˜ìŠ¤ì—ì„œë§Œ ì ‘ê·¼ ê°€ëŠ¥(ê°œì²´ì—ì„œê°€ ì•„ë‹˜)

ìë°”ì™€ ìˆœì„œê°€ ì¡°ê¸ˆ ë‹¤ë¥´ë‹¤.

```cpp
class SomeClass
{
  public:
    int PublicMember;
  protected:
    int mProtectedMember;
  private:
    int mPrivateMember1;
    int mPrivateMember2;
};
```

## friend í‚¤ì›Œë“œ

ë‹¤ë¥¸ í´ë˜ìŠ¤ì˜ í•¨ìˆ˜ê°€ ë‚˜ì˜ private ë˜ëŠ” protected ë©¤ë²„ì— ì ‘ê·¼í•  ìˆ˜ ìˆê²Œ í—ˆìš©.

íŒ¨í‚¤ì§€ ë°–ì— ìˆì–´ë„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

## ì •ì  ë°”ì¸ë”©

```cpp
// main.cpp
Cat* myCat = new Cat();
myCat->Speak(); // meow

Animal* yourCat = new Cat();
yourCat->Speak(); // Animal is speaking
```

## ê°€ìƒ í•¨ìˆ˜(ë‹¤í˜•ì„±ì˜ í•µì‹¬)

JAVAì˜ abstractì™€ ë¹„ìŠ·í•˜ë‹¤.

ìì‹í´ë˜ìŠ¤ì˜ ë©¤ë²„í•¨ìˆ˜ê°€ ì–¸ì œë‚˜ í˜¸ì¶œë¨. ë¶€ëª¨ì˜ í¬ì¸í„°ë¥¼ ì‚¬ìš©ì¤‘ì´ë”ë¼ë„.

ë™ì  ë°”ì¸ë”©ì„ ì‚¬ìš©í•˜ì—¬, ì‹¤í–‰ ì¤‘ì— ì–´ë–¤ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí• ì§€ ê²°ì •í•œë‹¤. ì •ì  ë°”ì¸ë”©ë³´ë‹¤ ëŠë¦¬ë‹¤.

ì´ë¥¼ ìœ„í•´ í´ë˜ìŠ¤ë§ˆë‹¤ ê°€ìƒ í…Œì´ë¸”ì´ ìƒì„±ëœë‹¤.

ê°€ìƒì„±ì€ ëª¨ë“  ìì‹ì—ê²Œ ìƒì†ëœë‹¤.

ìë°”ëŠ” ëª¨ë“  í•¨ìˆ˜ê°€ ê¸°ë³¸ì ìœ¼ë¡œ ê°€ìƒ í•¨ìˆ˜ë‹¤.

```cpp
// Animal.h
class Animal
{
public:
  virtual void Move();
  virtual void Speak();
};

// Animal.cpp
void Animal::Move()
{
};

void Animal::Speak()
{
  std::cout << "An animal is speaking" << std::endl;
};

// Cat.h
class Cat : public Animal
{
public:
  void Speak();
};

// Cat.cpp
void Cat::Speak()
{
  std::cout << "Meow" << std::endl;
};

// Main.cpp
Cat* myCat = new Cat(2, "Coco");
myCat->Speak(); // Meow

Animal* yourCat = new Cat(5, "Mocha");
yourCat->Speak(); // Meow
```

Java í”„ë¡œê·¸ë˜ë¨¸ëŠ” final í‚¤ì›Œë“œë¥¼ ì“¸ ìˆ˜ ìˆìŒ. ì´ê±¸ ê¹Œë¨¹ìœ¼ë©´ ë¹„ ê°€ìƒí•¨ìˆ˜ë³´ë‹¤ ì–¸ì œë‚˜ ëŠë¦¼.

C++ì€ virtual í‚¤ì›Œë“œë¥¼ ìƒëµí•˜ë©´ ì •ë§ ê°œíŒë‚  ìˆ˜ ìˆë‹¤. ë‹¤í˜•ì„±ì„ ì›í•˜ë©´ virtualì„ ê¼­ ì“°ì.

## ì†Œë©¸ì

```cpp
// vector.h
class Vector
{
public:
  ~Vector();
private:
  int mX;
  int mY;
};

// vector.cpp
Vector::~Vector()
{
};
```

### ê°€ìƒ ì†Œë©¸ì

ë‹¤ìŒì€ ë¬¸ì œê°€ ìˆëŠ” ì½”ë“œë‹¤.

```cpp
// Animal.h
class Animal
{
public:
  ~Animal();
private:
  int mAge;
};

// Cat.h
class Cat : public Animal
{
public:
  ~Cat();
private:
  char* mName;
};

// Cat.cpp
Cat::~Cat()
{
  delete mName;
}
```

ì´ëŸ¬ë©´ ë‹¤ìŒì—” ë¬¸ì œê°€ ì—†ë‹¤.

```cpp
Cat* myCat = new Cat(2, "Coco");
delete myCat;
```

ê·¸ëŸ¬ë‚˜ ë‹¤ìŒì—” ì •ì ë°”ì¸ë”© ë•Œë¬¸ì— ë¬¸ì œê°€ ìƒê¸´ë‹¤.

```cpp
Animal* yourCat = new Cat(5, "Mocha");
delete yourCat;
```

ì†Œë©¸ìë¥¼ ê°€ìƒ ì†Œë©¸ìë¡œ ë§Œë“¤ì–´ì£¼ì–´ì•¼í•œë‹¤.

```cpp
// Animal.h
class Animal
{
public:
  virtual ~Animal();
private:
  int mAge;
};

// Cat.h
class Cat : public Animal
{
public:
  // ì—¬ê¸°ëŠ” virtual ìƒëµ ê°€ëŠ¥í•˜ì§€ë§Œ ë„£ì–´ì£¼ëŠ”ê²Œ ì¢‹ë‹¤
  virtual ~Cat();
private:
  char* mName;
};
```

ëª¨ë“  ì†Œë©¸ìëŠ” virtual ë„£ì–´ì£¼ì!

ê·¸ëŸ°ë° ê°€ìƒ ì†Œë©¸ìê°€ ìˆëŠ” í´ë˜ìŠ¤ë¥¼ ìƒì†ë°›ì§€ ì•Šì•„ë„ ì´ë˜ì•¼í• ê¹Œ?

C++ 14/17ì—ëŠ” í•´ê²°ì±…ì´ ìˆë‹¤.

## ë‹¤ì¤‘ ìƒì†

C++ì€ ë‹¤ì¤‘ìƒì†ì„ ì§€ì›í•œë‹¤. ê·¸ë˜ì„œ super()ê°€ ì—†ë‹¤. ì–´ë–¤ ë¶€ëª¨ë¥¼ ë§í•˜ëŠ”ì§€ ëª¨ë¥´ê¸° ë•Œë¬¸.

```cpp
// Student(), Faculty() ìˆœìœ¼ë¡œ í˜¸ì¶œ
class TA : public Student, public Faculty
```

## ì¶”ìƒ í´ë˜ìŠ¤

êµ¬í˜„ì²´ê°€ ì—†ëŠ” ìˆœìˆ˜ ê°€ìƒí•¨ìˆ˜ë¥¼ ê°€ì§€ê³  ìˆëŠ” ë² ì´ìŠ¤ í´ë˜ìŠ¤.

íŒŒìƒ í´ë˜ìŠ¤ì—ì„œ ì´ë¥¼ êµ¬í˜„í•´ì•¼í•œë‹¤.

```cpp
// Animal.h
class Animal
{
public:
  virtual ~Animal();
  // virtual <return-type> ì´í›„ =0(NULL) ë¡œ ì¶”ìƒ í´ë˜ìŠ¤ ì •ì˜
  // ìˆœìˆ˜í•œ ê°€ìƒí•¨ìˆ˜ë¥¼ ê°€ì§„ë‹¤.
  virtual void Speak() = 0;
private:
  int mAge;
}

// Cat.h
class Cat : public Animal
{
public:
  ~Cat();
  void Speak();

private:
  char* mName;
}
```

## ì¸í„°í˜ì´ìŠ¤

ë°ì´í„°ê°€ ì „í˜€ ì—†ì´ ìˆœìˆ˜ ê°€ìƒí•¨ìˆ˜ë§Œ ê°€ì§€ëŠ” í´ë˜ìŠ¤

# ìºìŠ¤íŒ…

```cpp
static_cast<int>(number1);
```

- static_cast: ì •ì  ìºìŠ¤íŒ…
- const_cast: constë¥¼ const ì•„ë‹Œ ê²ƒìœ¼ë¡œ ìºìŠ¤íŒ…
- dynamic_cast: ë™ì  ìºìŠ¤íŒ…. ì‹¤í–‰ì¤‘ì—
- reinterpret_cast

# STL

- vector
- map
- set
- stack
- queue
- list
- deque

## Vector

ì–´ë–¤ ìë£Œí˜•ë„ ë„£ì„ ìˆ˜ ìˆëŠ” ë™ì  ë°°ì—´

reserveë¡œ ì´ˆê¸°í™”, push_back, pop_back, size, capacity, resize

ë‹¤ìŒì²˜ëŸ¼ í•˜ë©´ ëª¨ë‘ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•´ì¤€ë‹¤. ê·¸ëŸ¬ë‚˜ ê´œíˆ ì´ˆê¸°í™”í•  í•„ìš”ê°€ ì—†ë‹¤. reserveë¥¼ ì“°ì.

```cpp
std::vector<int> scores(10);
```

### Iterator

```cpp
for (std::vector<int>::iterator iter = scores.begin(); iter != scores.end(); ++iter)
{
  std::cout << *iter << " ";
}
```

í˜¹ì€ `std::vector<int>::iterator` ë¥¼ `auto`ë¡œ ì‚¬ìš©í•˜ì.

reverse_iterator ë„ ìˆë‹¤. rbegin, rend

# Map

ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ê¸°ë°˜. Keyì— ë”°ë¼ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ìë™ ì •ë ¬ëœë‹¤. (rbtree)

```cpp
std::map<std::string, int> simpleScoreMap;

simpleScoreMap.insert(std::pair<std::string, int>("Mocha", 100));

// operator[] ì°¸ì¡°ë¥¼ ì‚¬ìš©. í‚¤ê°€ ì—†ìœ¼ë©´ ì‚½ì…, ìˆìœ¼ë©´ ë®ì–´ì”€
simpleScoreMap["Mocha"] = 0;
```

findë¥¼ ì“°ë©´ ì¢€ ë” ì•ˆì „í•˜ê²Œ ë°›ì•„ì˜¬ ìˆ˜ ìˆë‹¤.

```cpp
std::map<std::string, int> simpleScoreMap;
simpleScoreMap.insert(std::pair<std::string, int>("Mocha", 100));

std::map<std::string, int>::iterator it = simpleScoreMap.find("Mocha");

// ì°¾ì§€ ëª»í•˜ëŠ” ê²½ìš° endë¥¼ ë°˜í™˜
if(it != simpleScoreMap.end())
{
  it->second = 80;
}
```

eraseë¡œ ìš”ì†Œ ì œê±° ê°€ëŠ¥. ì´í„°ë ˆì´í„°ë¥¼ ë„£ì–´ë„ë˜ê³ , í‚¤ë¥¼ ë„£ì–´ë„ëœë‹¤.

ê°œì²´ë¥¼ í‚¤ë¡œ ì‚¬ìš©í•  ë•ŒëŠ” `operator<`ë¥¼ ì •ì˜í•´ì¤˜ì•¼í•œë‹¤. ë§µì€ ì–¸ì œë‚˜ ì •ë ¬ì„ í•˜ê¸° ë•Œë¬¸ì´ë‹¤.

ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ ì •ë ¬í•˜ê³  ì‹¶ì€ ê²½ìš° ë§µì„ ë§Œë“¤ ë•Œ comparer í•¨ìˆ˜ë¥¼ ë”°ë¡œ ë„£ì„ ìˆ˜ ìˆë‹¤.

```cpp
struct StudentInfoComparer
{
  bool operator()(const StudentInfo& left, const StduentInfo& right)
  {
    return (left.getName() < right.getName());
  }
};

std::map<StudentInfo, int, StudentInfoComparer> Scores;
```

## Set

ì…‹ì€ ë‹¤ìŒê³¼ ê°™ì´ ì‚¬ìš© ê°€ëŠ¥.

```cpp
std::set<int> scores;

for (std::set<int>::iterator it = scores.begin(); it!=scores.end(); ++it)
{
  // ...
}
```

## List

double linked listë¥¼ êµ¬í˜„í•œë‹¤. front, backìœ¼ë¡œ êµ¬ë¶„ë¨. operator[] ê°€ ì—†ìŒ.

push_front, push_back

í•„ìš”í• ë•Œë§ˆë‹¤ êµ¬ê¸€ì—ì„œ ê²€ìƒ‰í•´ì„œ ì“°ì.

## ì•Œê³ ë¦¬ì¦˜

ë„ˆë¬´ ë§ìŒ. ì“¸ ë•Œ ì°¸ê³ í•˜ì.

http://www.cplusplus.com/reference/algorithm/

findì™€ sortë¥¼ ì œì¼ ë§ì´ ì”€.

#include <algorithm>

ë³€ê²½ ë¶ˆê°€ ìˆœì°¨ ì—°ì‚°

- find(), for_each(), ...

ë³€ê²½ ê°€ëŠ¥ ìˆœì°¨ ì—°ì‚°

- copy(), swap(), ...

ì •ë ¬ ê´€ë ¨ ì—°ì‚°

- sort(), merge(), ...

#include <numeric>

ë²”ìš© ìˆ˜ì¹˜ ì—°ì‚°

- accumulate(), ...

# References

https://www.learncpp.com/
