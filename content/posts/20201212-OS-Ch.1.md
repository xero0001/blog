---
title: 🦕 OPERATING SYSTEM CONCEPTS - 1. 개요
description: 공룡책 정리하기
date: "2020-12-12S01"
tags: "운영체제"
---

# Introduction

OS는 유저와 다양한 종류의 하드웨어 사이의 매개체 역할을 한다. 현대 OS의 가장 기본적인 역할은 CPU, 메모리, I/O 디바이스, 스토리지와 같은 하드웨어의 자원을 프로그램에 할당하는 것이기 때문에, 이 하드웨어의 구조를 이해하는 것이 가장 중요하다.

## 1 OS가 하는 일

컴퓨터 시스템은 다음 네가지 요소로 구성된다.

- 하드웨어(CPU, 메모리, I/O 디바이스, 스토리지)
- OS
- App 프로그램(웹 브라우저, 워드 프로세서 등)
- 유저

운영체제는 정부와 비슷하다. 그 자체만으로는 쓸모있는 기능을 못하지만, 프로그램에게는 의미있는 환경을 제공한다. 이를 더 잘 이해하기 위해서 OS에 대한 두가지 관점을 살펴보자.

### 1.1 User View

User view는 사용되는 인터페이스에 따라 다를 수 있다.

- 키보드 마우스를 사용하는 데스크탑
- 무선기술과 터치 스크린을 사용하는 모바일 기기
- 음성인식을 통하는 애플의 Siri
- 자동차나 홈 디바이스와 같이 user view가 없다시피한 경우

어떤 경우든 사용자가 컴퓨터를 쉽게 사용하면서도 유저의 능률을 극대화시키는것에 초점을 맞춘다.

### 1.2 System View

컴퓨터의 관점에서 OS는 하드웨어와 가장 가까운 프로그램이다.

- OS를 자원 분배자(resource allocator)의 역할로 볼수도 있다. 컴퓨터 시스템은 문제를 해결하기 위한 다양한 자원을 가지고 있는데, 다양한 상황에 맞게 어떻게 효율적으로 자원을 나눌것인지에 대해 결정한다.
- 다양한 입출력장치와 유저 프로그램을 제어하는 역할로 보는 제어 프로그램(control program)의 관점이다. 에러와 오동작을 방지하는데, 특히 입출력장치의 제어와 연관이 깊다.

### 1.3 OS의 정의

OS는 발전의 역사가 있고, 무수히 많은 역할과 디자인을 가지고 있다. 공통적으로 OS는 컴퓨팅 시스템을 통해 문제를 잘 해결하는것을 목적하고 있다고 볼 수 있다.
조금 더 일반적인 정의로는, OS는 컴퓨터에 항상 실행되며 시스템을 통제하는 것이라 볼 수 있기 때문에, 커널(kernel) 그 자체로 보는 것이다.

OS에는 커널과 함께 두가지 종류의 프로그램이 있다.

- 시스템 프로그램(system program): 커널에 속하진 않지만 OS와 연관이 깊은 프로그램.
- 응용 프로그램(application program): 시스템 동작과 연관이 없는 프로그램.

모바일에서는 코어 커널뿐 아니라 다른 앱에 기능을 제공하는 미들웨어도 다수 존재한다.

## 2 컴퓨터-시스템 구조(organization)

![Organization](os/organization.jpg)

일반적인 컴퓨터 시스템은 여러개의 CPU와 디바이스 컨트롤러(Device controllers)로 구성되어 있다. 그리고 이들은 공통버스(Commmon bus)로 이어져 서로에게 접근하거나, 메모리를 공유한다.
각 디바이스엔 디바이스 컨트롤러가 붙어있고, 한 디바이스에 여러 컨트롤러가 붙어있을 수도 있다(예를 들면 USB). OS는 각 디바이스 컨트롤러에 대한 디바이스 드라이버를 갖고있다. 이제 OS가 어떻게 이들을 제어하는지에 대해 알아보자.

### 2.1 인터럽트

입출력 장치는 CPU와 동시에 수행될 수 있기 때문에 입출력 장치가 작업을 시작하거나 끝마칠 때 이를 인터럽트 신호를 통해 OS 커널에 알릴 수 있다.

입출력은 다음과같이 작동한다.

- 디바이스 드라이버가 디바이스 컨트롤러에 레지스터를 등록.
- 디바이스 컨트롤러가 레지스터에 맞는 행동을 취함.
- 컨트롤러는 디바이스로부터 데이터를 전송받아 로컬 버퍼에 저장.
- 데이터 전송이 끝나면 드라이버에 이를 알림 <- 주목
- 드라이버가 OS의 다른 부분에 제어권을 넘겨줌. 이 때 데이터 혹은 데이터가 위치한 포인터를 리턴함. 혹은 디바이스 드라이버가 상태 메시지를 리턴함.

컨트롤러가 디바이스 드라이버에 동작이 끝났음을 알리는 동작은 인터럽트를 통해 이뤄짐.

![Interrupt](os/interrupt.jpg)

하드웨어의 경우 시스템 버스(System bus)를 통해 CPU에 신호를 보냄으로써 인터럽트를 발생시키고, 소프트웨어는 시스템 콜(System call)이라는 특별한 명령으로 인터럽트를 발생시킨다.

#### 2.1.1 Overview

하드웨어는 시스템 버스를 통해 인터럽트 시그널을 언제든지 보낼 수 있다. 참고로 버스는 여러개가 있지만, 시스템 버스는 주요 장치간의 주요 통신로다. CPU가 인터럽트되면, 하던것을 멈추고 메모리의 특정 위치(fixed location)를 실행한다. 이곳엔 주로 해당 인터럽트를 위한 서비스 루틴이 존재한다. 이들은 주로 메모리의 낮은 주소에 위치하고, 이 위치엔 다양한 루틴에 대한 배열이 존재하는데, 이 배열의 주소들을 인터럽트 벡터(interrupt vector)라고 부른다.

#### 2.1.2 구현

CPU는 interrupt-request line을 통해 인터럽션을 감지하고, 감지 후에는 interrupt vector의 인덱스에 해당하는 interrupt-handler routine으로 점프한다. 핸들러는 state를 저장하고, 루틴을 처리한 뒤에 state를 복원한다. 이후에는 interrupt-request의 상태를 clear한다.

OS는 인터럽트 주도 시스템(Interrupt Driven System)이다. 인터럽트라고 하면 주가 아니라 일종의 예외와 같은것이라 생각할 수 있는데, 사용자의 입장에서 볼 때 프로그램들이 전부 자신의 I/O없이 자기 마음대로 코드를 실행한다면, 그것이 더 이상할지도 모른다.

### 2.2 스토리지의 구조

컴퓨터를 처음 켤 때는 bootstrap program을 통해 켜지는데, 이것은 비휘발성인 EEPROM에 저장되어있다.

다음으로 메인 메모리로부터 명령어를 읽기 시작하는데, 이 명령어는 instruction register로 fetch되며 실행된다.

메모리의 계층은 레지스터-캐시-메인 메모리-비휘발성 메모리-하드디스크 순으로 CPU와 가깝다. CPU와 가까울수록 용량은 작아지고 접근속도는 빨라진다.

느린 보조기억장치로부터 인터럽트를 받으며 CPU를 통해 메모리에 대용량 데이터를 전송하는것은 바람직하지 못하다. 그렇기 때문에 Direct Memory Access 기능을 사용해 보조기억장치가 직접 메인 메모리에 데이터를 전송하도록한다.

# 3. 컴퓨터 시스템 설계(architecture)

![I/O Structure](os/iostructure.jpg)

현대의 컴퓨터 시스템은 주로 메모리에 프로그램을 로드해 명령어를 실행하는 폰 노이만 구조를 따른다.

## 3.1 싱글 프로세서 시스템

하나의 CPU에 하나의 코어를 갖는 시스템이다. 요즘엔 특별한 목적의 시스템이 아니라면 찾아보기 힘들다.

## 3.2 멀티 프로세서 시스템

N개의 프로세서를 갖는 시스템이다. 그러나 처리속도가 1코어의 N배가 되지는 않는다. 멀티코어 프로세서의 경우는 하나의 CPU가 여러개의 코어로 구성된 경우인데, 한 CPU내의 코어들은 L2 캐시를 공유하므로 처리효율이 상승한다.

- symmetric multiprocessing(SMP)이 가장 흔하며, 동일한 캐시, 레지스터, 성능을 갖는 프로세서들 모든 일을 동등하게 맡는 시스템이다. 이상적인 경우 N개의 프로세스를 N개의 CPU가 맡아서 하므로 성능이 매우 좋으나, 다른 CPU에 비해 하나의 CPU가 과부하가 걸리는 문제가 발생하기도 한다.

- assymmetric multiprocessing은 몇몇개의 프로세서가 다른 프로세서보다 뛰어나며, 다른 프로세서에게 일을 맡기는 역할을 한다. 그렇기 때문에 부하분산에 있어 뛰어나다.

# 4. OS 작동방식

OS의 구조과 아키텍쳐에 대해 이야기했으므로, 이제 OS에대해 이야기할 수 있다.

앞서 말했듯 부트스트랩 프로그램이 펌웨어로써 EEPROM으로부터 불리고, OS의 커널을 메인 메모리로 로드한다. 몇몇 시스템 프로그램이 커널로부터 서비스를 제공받은 뒤에 system daemon이 된다. 이는 커널이 꺼질때까지 계속 같이 실행된다.

완전히 부팅이 되고 난 뒤에 시스템은 조용히 인터럽트를 기다린다. 인터럽트를 통해 시스템은 동작하게된다. 소프트웨어로부터의 인터럽트는 trap 혹은 exception이라고 부르고, 에러나 유저 프로그램이 OS에 보내는 요청인 시스템 콜을 통해 발생한다.

## 4.1 멀티 프로그래밍과 멀티 태스킹

멀티 프로그래밍은 메모리에 여러 프로그램을 올려두고 I/O 등의 이유로 기다려야 할 때 다른 프로그램을 실행하는 방식이다. 실행한 프로그램이 계속 있는 동안은 CPU가 절대로 쉬지 못하게한다.

멀티 태스킹은 시간을 분할하여 빠르게 여러개의 프로그램을 스위칭하며 실행함으로써 반응속도를 감소시키는 방식이다.

가상메모리는 좁은 메인 메모리에 이를 초과하는 크기의 프로세스들을 실행시키는 방법이다. 필요한 부분만 메인메모리에 두었다가 추상화된 logical memory 주소를 통해 보조 스토리지를 사용함으로써 물리적인 메인 메모리의 한계를 뛰어넘는다.

## 4.2 듀얼 모드와 멀티모드

![Dual mode](os/dualmode.jpg)

운영체제는 사용자 프로그램이 함부로 시스템에 접근하지 못하도록 모드(Modes)를 나눠둔다. 유저 모드(User mode)와 커널 모드(Kernel mode)가 그것이며, 하드웨어의 모드 비트(Mode bit)가 0은 커널 모드, 1은 유저 모드임을 가리킨다.

사용자 모드에서 커널 모드로 변경되는 과정. 시스템 콜을 이용.

이러한 이중 모드(Dual-mode) 방식을 사용하면 나쁜 의도를 가진 사용자로부터 운영체제, 하드웨어를 비롯한 시스템과 사용자를 보호할 수 있다. 하드웨어는 커널 모드일 때만 특권 명령(Privileged instructions)를 실행한다. 만약 유저 모드에서 특권 명령을 실행하려 한다면 하드웨어는 이 동작을 막고 운영체제에게 트랩을 보낼 것이다. 유저 모드에서 합법적으로(?) 커널 모드의 기능을 호출하고 싶다면 시스템 콜(System call)이라는 인터페이스를 통해야 한다.

## 4.3 타이머

운영체제는 사용자의 프로그램이 제어권을 운영체제에게 넘겨주지 않는 상황을 방지하기 위해 타이머(Timer)를 사용한다. 타이머는 운영체제에게 제어권을 보장하기 위해 특정 주기에 인터럽트를 발생시킨다. 운영체제는 카운터를 설정하고, 타이머의 시간은 매 틱(Ticks)마다 감소한다. 그렇게 카운터가 0에 도달하면 인터럽트가 발생한다.

# 5. 자원 관리

## 5.1 프로세스 관리

디스크에 있으면 프로그램, 메모리에 로드되면 프로세스다. 프로그램은 하나지만 프로세스는 여러 개일 수 있다. 강조할 점은, 프로그램은 디스크에 저장되어 있는 수동적(Passive) 존재인 반면 프로세스는 능동적(Active) 존재다. 프로그램은 하나지만 프로세스는 여러 개일 수 있다. 또한 프로세스는 프로그램이 어디까지 실행되었는지 북마크하는 프로그램 카운터(Program counter)를 가지고 있다. 싱글쓰레드(Single-thread) 프로세스는 하나의 프로그램 카운터를 가지고 있으며, 멀티쓰레드(Multi-threads) 프로세스는 여러개의 프로그램 카운터를 가지고 있다.

운영체제는 프로세스 관리를 위해 CPU에게 프로세스와 쓰레드를 스케줄링하고, 프로세스를 생성하거나 제거하는 활동을 한다. 뿐만 아니라 일시정지하거나 재실행하고, 프로세스의 동기화(Synchronization)와 통신도 제공한다.

## 5.2 메모리 관리

메인 메모리는 현대 컴퓨터 시스템의 핵심이며, 방대한 바이트의 배열이다. 그리고 각 바이트는 그들만의 주소를 가지고 있다. 폰 노이만 구조에 의하면 프로그램이 실행되기 위해서는 메인 메모리에 프로세스의 형태로 적재되어야만 한다.

이후 프로그램이 실행될 때 프로그램은 절대 주소(Abolute addresses)로 매핑(Mapping)되어 메모리에 로드된다. 메모리 관리는 여러 요인을 고려해야 하는 작업이며, 특히 시스템의 하드웨어 설계를 신경써야 한다.

운영체제는 메모리 관리를 위해 메모리의 어떤 부분이 어디에 쓰이는지, 누가 사용하는지 추적하고, 어떤 프로세스와 데이터가 메모리의 안팎으로 옮겨질지 결정한다. 또한 메모리 공간을 할당하고 해제하는 것도 운영체제가 하는 일이다.

## 5.3 파일 시스템 관리

운영체제는 저장장치의 물리적 속성을 추상화해 파일(File)이라는 논리적 저장 단위로 정의하며, 파일을 물리적 매체(Physical media)에 담거나 저장장치의 파일에 접근하기도 한다.

파일 관리는 운영체제가 하는 일 중 가장 눈에 잘 보이는 요소다. 운영체제는파일을 생성, 제거하며, 당연히 읽기, 쓰기도 한다.

## 5.4 대용량 저장소 관리

프로그램은 디스크에 담겨 있으며, 메인 메모리에 로드되어 실행된다. 많은 사람들이 제3의 저장 장치(Tertiary storage devices)를 사용한다. 저장 장치들은 WORM(Write-Once, Read-Many-Times)과 RW(Read-Write) 형식에 차이가 있다. 한번쯤 봤을 NTFS, FAT가 파일 저장 형식이며, 이를 파일 시스템(File system)이라고 부른다. 파일 시스템이 다르면 읽기는 가능하지만 쓰기가 불가능하다.

## 5.5 캐시 관리

캐싱(Caching)은 컴퓨터 시스템에 있어 정말 중요한 부분이다. 캐시는 굉장히 빠르고 작은 저장장치이며, 캐싱은 캐시 메모리를 사용해 컴퓨터의 속도를 높이는 기술이다. 데이터를 디스크에서 직접 가져오는 것은 너무 느리기 때문에 캐시에 자주 사용될 것 같은 데이터를 미리 담아두고, CPU나 디스크가 캐시의 데이터를 참조할 수 있도록 한다. 파일의 중복성이 증가하지만, 속도 역시 증가한다. 캐싱은 지역성(Locality) 원리를 사용하며 두가지로 나뉜다.

- 시간지역성(Temporal locality): 한 번 접근한 데이터에 다시 접근할 확률이 높다는 것이다.
- 공간지역성(Spatial Locality): 특정 데이터와 가까운 메모리 주소에 있는 다른 데이터들에도 접근할 가능성이 높다는 것이다.

### 시간지역성

```cpp
for (int i = 0; i < 10; i++) { ... }
```

위 코드에서 변수 i가 그 예시다. 이전 루프에서 사용했으니 다음 루프에서도 재사용할 가능성이 높다. 짧은 시간 내에 여러번 불러진다.

### 시간지역성

```cpp
for (int i = 0; i < 10; i++) {
  arr[i] += 1;
}
```

배열 변수 arr의 0번 요소부터 순서대로 9번 요소까지 접근한다. 메모리 공간에 배열의 요소들은 그 순서대로 붙어 할당되니까 실제로 가까운 메모리 공간에 연속적으로 접근하고 있다. 캐시는 한 메모리 주소에 접근했을 때 그 주변의 메모리 주소도 함께 가져온다.

## 5.6 입출력 시스템 관리

운영체제는 모든 입출력장치를 파일로 취급한다. 오직 장치드라이버(Device driver)만이 장치의 자세한 정보를 알고 있다.

# 6. 보안과 보호

컴퓨터 시스템은 여러 사람들이 사용하기 때문에 보호와 보안도 매우 중요하다. 운영체제는 내외부로부터 컴퓨터를 위험하게 만드는 요소를 막기 위해 다양한 활동을 한다. (유저 모드와 커널 모드를 나눈 것도 보호의 일종이다.) 권한 확대(Privilege escalation)는 컴퓨터 시스템의 권한을 여러 층으로 나누고, 사용자의 권한을 구분해 어떤 행동이나 기준에 따라 사용자의 권한을 상승시키는 시스템이다. 참고로 권한 확대는 수직 권한 확대와 수평 권한 확대로 나눌 수 있는데, 가령 임의의 코드를 실행시켜 더 높은 권한을 얻는 행위는 수직 권한 확대, 안드로이드 루팅, iOS 탈옥은 수평 권한 확대라고 한다.

# 7. 커널 자료구조

커널 구현에는 기본적인 리스트(List), 스택(Stack), 큐(Queue), 링크드리스트(Linked list) 등의 자료구조가 사용된다. 해쉬 함수를 활용한 맵(Map)도 활용된다. 특히 트리(Tree)는 상당히 효율적인 O(\log n)O(logn)의 시간복잡도를 가질 수 있기 때문에 자주 사용된다.

# 8. 컴퓨팅 환경

모바일 컴퓨팅(Mobile computing) 환경은 컴퓨터의 접근성을 높였고, 다양한 센서를 통해 사용자와의 인터페이스를 확장시켰다. 또한 분산형 컴퓨팅(Distributed computing), 클라이언트-서버 컴퓨팅(Client-Server computing), P2P 컴퓨팅(Peer-to-Peer computing) 등 다양한 컴퓨팅 환경이 있다. 특히 클라우드 컴퓨팅(Cloud computing)은 AWS(Amazon Web Service)를 통해 상당히 잘 알려졌다. 현대 컴퓨팅 환경의 가장 큰 특징을 꼽자면 휴대성, 가상화, 멀티코어가 있다.

# 9. 무료 오픈소스 OS

세상에는 많은 오픈소스 운영체제들이 있다. 당장 깃허브에서도 리눅스의 코드를 찾아볼 수 있다. 오픈소스 운영체제 개발에는 누구나 참여할 수 있고, 이를 이용해 새로운 운영체제를 만들 수도 있다.

# References

[🦕 공룡책으로 정리하는 운영체제 Ch.1 (parksb.github.io) - 9판](https://parksb.github.io/article/5.html#computer-system-organization)

[운영체제 공룡책 정리 🦖 ch01. 운영체제 개요](https://aerocode.net/370?category=798030)
