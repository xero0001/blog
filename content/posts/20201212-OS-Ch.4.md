---
title: 🦕 OPERATING SYSTEM CONCEPTS - 4. 쓰레드와 컨커런시
description: 공룡책 정리하기
date: "2020-12-12S04"
tags: "운영체제"
---

# 1. 쓰레드

## 1.1 쓰레드의 구성

쓰레드는 프로세스의 작업 흐름을 말한다. 하나의 프로세스가 한 번에 하나의 작업만 수행하는 것은 싱글쓰레드(Single thread)이며 챕터 3에서는 싱글쓰레드를 가정하며 설명했다. 하나의 프로세스가 동시에 여러 작업을 수행하는 것은 멀티쓰레드(Multi thread)라고 한다.

쓰레드는 CPU 이용의 기본 단위이며, 각 쓰레드는 개인 쓰레드 메모리와 프로세스의 공유 메모리에 접근할 수 있다. 쓰레드의 구성은 다음과 같다. 공유 메모리엔 전역 변수가 들어있고, 각 쓰레드에는 각 쓰레드에서 사용하는 로컬 변수가 들어있다.

- 쓰레드 ID
- 프로그램 카운터
- 레지스터 집합
- 스택

다음 그림은 싱글 쓰레드와 멀티 쓰레드의 차이를 보여준다.

![Thread](os/thread.jpg)

## 1.2 쓰레드의 장점

멀티프로그래밍 시스템이니까 프로세스를 여러개 돌려도 되는데 굳이 쓰레드를 나누는 데는 이유가 있다.

1. 두 프로세스가 하나의 데이터를 공유하려면 메시지 패싱이나 공유 메모리 또는 파이프를 사용해야 하는데, 효율도 떨어지고 개발자가 구현, 관리하기도 번거롭다.
2. 프로세스 사이 컨텍스트 스위치가 계속 일어나면 성능 저하가 발생한다. 쓰레드 전환에도 컨텍스트 스위치가 일어나지만 속도가 더 빠르다. 프로세스에 비하면 생성시간은 5배정도, 컨텍스트 스위칭은 30배정도 빠르다.

## 1.3 멀티쓰레드 서버 아키텍쳐

서버와 클라이언트 사이에도 멀티스레드를 구현한다. 클라이언트가 서버에게 요청을 보내면 서버는 새로운 스레드를 하나 생성해 요청을 수행한다. 프로세스를 생성하는 것보다 스레드를 생성하는 것이 더 빠르기 때문이다.

# 2. 멀티코어 프로그래밍

![Concurrency](os/concurrency.jpg)

![Parallelism](os/parallel.jpg)

이렇게 멀티코어 또는 멀티프로세서 시스템을 구현할 때는 동시성(Concurrency)와 병렬성(Parallelism)을 알아야 한다.

동시성은 여러개의 업무가 계속 진행되는 개념인데, 싱글 프로세서 시스템에서도 구현 가능하다. 한 프로세서가 여러 개의 쓰레드를 시분할로 번갈아 수행하여 여러 업무가 동시에 실행되는 것처럼 보이게 하는 방식이다.

병렬성은 멀티코어 시스템에서 사용되는 방식으로, 여러 개의 코어가 각 쓰레드를 동시에 수행하는 방식이다.

## 2.1 Amdahl's law

컴퓨팅 코어를 추가할 때 serial 하거나 parallel한 부분을 둘 다 가지는 앱을 실행했을 때 성능의 향상이 얼마나 일어나는지에 관한 법칙이다.

S가 시스템에서 실행되는 serial한 부분의 비율이고, N이 코어의 갯수라면 다음을 따른다:

$$speedup \le \frac{1}{S + frac{1-S}{N}}$$

## 2.2 멀티 코어 프로그래밍에서 고려할 점

1. 태스크 분리: 서로 다른 태스크는 서로 다른 코어에서 실행할 수 있다.
2. 균형: 서로 다른 코어에서 실행할 수 있더라도, 두 태스크의 양이 비슷해야한다.
3. 데이터 쪼개기: 앱이 여러 태스크로 나눠지는것 처럼, 태스크에 의해 조작되는 데이터도 여러개로 나뉘어져 각각의 코어에서 사용될 수 있다.
4. 데이터 의존성: 여러 태스크로부터 접근되는 데이터간의 의존성을 고려해야한다. 프로그래머는 이 태스크의 싱크를 맞추고, 의존성을 맞춰주어야한다. 이는 챕터 6에서 다룬다.

# 3. 멀티쓰레드 모델

![User and Kernel Thread](os/ukthread.jpg)

쓰레드는 시스템 콜의 권한을 가졌는지의 여부에 따라 커널 쓰레드와 유저 쓰레드로 나뉜다. 당연히 커널 쓰레드만 시스템 콜의 권한을 갖는다. 이는 보안을 위해서인데, 유저 쓰레드가 직접 시스템 콜을 하지 못하도록 하고, 커널 쓰레드를 통해 이를 확인받게 하기 위함이다.

## 3.1 Many-to-One Model

![Many to one](os/manytoone.jpg)

하나의 커널 스레드에 여러 개의 유저 스레드를 연결하는 모델이다. 한 번에 하나의 유저 스레드만 커널에 접근할 수 있기 때문에 멀티코어 시스템에서 병렬적인 수행을 할 수가 없다. 요즘에는 잘 사용되지 않는 방식이다.

## 4.3 One-to-One Model

![One to one](os/onetoone.jpg)

하나의 유저 스레드에 하나의 커널 스레드가 대응하는 모델이다. 동시성을 높여주고, 멀티프로세서 시스템에서는 동시에 여러 스레드를 수행할 수 있도록 해준다. 유저 스레드를 늘리면 커널 스레드도 똑같이 늘어나는데, 커널 스레드를 생성하는 것은 오버헤드가 큰 작업이기 때문에 성능 저하가 발생할 수 있다.

그러나 이는 쓰레드 풀을 통해 완화될 수 있기에, 현대의 운영체제가 선호하는 모델이다.

## 4.4 Many-to-Many Model

![Many to Many](os/manytomany.jpg)

여러 유저 스레드에 더 적거나 같은 수의 커널 스레드가 대응하는 모델이다. 시스템 콜 요청이 오면 가용 커널 쓰레드를 찾아 연결해준다. 멀티프로세서 시스템에서는 싱글프로세서 시스템보다 더 많은 커널 스레드가 만들어진다.

## 4.5 Two-level Model

![Two level](os/twolevel.jpg)

Many-to-Many 모델과 비슷한데, 특정 유저 스레드를 위해서는 1:1로 커널 스레드를 따로 제공하는 모델을 말한다. 점유율이 높아야 하는 유저 스레드를 더 빠르게 처리해줄 수 있다.

## 4.6 쓰레드 풀

스레드를 요청할 때마다 매번 새로운 스레드를 생성하고, 수행하고, 지우고를 반복하면 성능이 저하된다. 그래서 미리 스레드 풀에 여러 개의 스레드를 만들어두고 요청이 오면 스레드 풀에서 스레드를 할당해주는 방법을 사용한다.

# References

[🦕 공룡책으로 정리하는 운영체제 Ch.4 (parksb.github.io) - 9판](https://parksb.github.io/article/8.html)

[운영체제 정리 🦖 ch04. 다중 스레드 프로그래밍](https://aerocode.net/373?category=798030)
