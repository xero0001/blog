---
title: 🦕 OPERATING SYSTEM CONCEPTS - 6. 동기화
description: 공룡책 정리하기
date: "2020-12-12S06"
tags: "운영체제"
---

현대의 시스템은 여러 작업이 동시에 실행될 수 있고, 여러 작업이 공유 메모리를 통해 협력을 하기도 한다. 이를 각각 병렬성과 협력성이라고 부른다.

# 1. 배경

만약 두 프로세스가 동시에 어떤 변수의 값을 바꾼다면 프로그래머의 의도와는 다른 결과가 나올 것이다. 이처럼 **프로세스가 어떤 순서로 데이터에 접근하느냐에 따라 결과 값이 달라질 수 있는 상황을 경쟁 상태(race condition)**라고 한다.

# 2. 임계 영역 문제(critical section problem)

**코드상에서 경쟁 조건이 발생할 수 있는 특정 부분을 임계 영역(critical section)**이라고 부른다. 이러한 경쟁 상태를 해결하기 위한 기본적인 아이디어는 선행 작업이 공유자원의 사용을 끝낼 때까지 후행 작업이 공유자원을 사용할 수 없도록 작업 간 순서를 강제하는 것이다.

프로세스의 영역은 4가지 섹션으로 구성되어있고, 임계영역은 세가지의 요구 조건을 만족해야 해결할 수 있다.

![Typical Process](os/typicalprocess.jpg)

1. 진입 영역: 임계 영역으로의 접근 허가를 받는 지점
2. 임계 영역: 공유 자원을 사용하는 지점
3. 퇴출 영역: 접근 허가를 반납하는 지점
4. 나머지 영역: 그 외의 영역

요구조건:

- Mutual exclution (상호 배제): 이미 한 프로세스가 critical section에서 작업중일 때 다른 프로세스는 critical section에 진입해서는 안 된다.
- Progress (진행): critical section에서 작업중인 프로세스가 없다면 다른 프로세스가 critical section에 진입할 수 있어야 한다.
- Bounded waiting (한정 대기): critical section에 진입하려는 프로세스가 무한하게 대기해서는 안 된다.

Non-preemptive kernels로 구현하면 임계 영역 문제가 발생하지 않는다. 하지만 비선점 스케줄링은 반응성이 떨어지기 때문에 슈퍼 컴퓨터가 아니고선 잘 사용하지 않는다.

# 3. 임계 영역 해결법

## 3.1 Peterson's Solution

Peterson's solution으로 임계 영역 문제를 해결할 수 있다. 임계 영역에서 **프로세스가 작업중인지 저장하는 변수** `flag`와 **critical section에 진입하고자하는 프로세스를 가리키는 변수** `turn` 을 만들어 어떤 프로세스가 임계 영역에 진입하면 `flag`를 `lock`하고, 나오면 `unlock`하는 방식으로 임계 영역 문제를 해결한다.

```c
do {
  flag[i] = true;
  turn = j;
  while (flag[j] && turn == j);
  // Critical section
  flag[i] = false;
  // Remainder section
} while(true);
```

그러나 이 방식은 선점이 발생하는 현대 시스템에서는 올바르게 작동하지 않을 수 있다. 인터럽트를 disable하여 선점이 발생하지 못하도록 할 수는 있으나, 매우 비효율적이어서 현대 시스템에서는 사용하지 않는다.

대신 하드웨어에서 제공하는 일종의 transaction을 만들어 도중에 선점되지 않는 Lock을 구현할 수 있다.

## 3.2 뮤텍스 락

하드웨어 기반의 솔루션은 사용하기 어렵다. 임계 영역에 접근하기 위해서 `lock`을 획득하는 것을 필수로 만들고, 오직 하나의 프로세스만이 `lock`을 획득할 수 있도록 하는 것이 mutex lock 기법이다. 이는 OS에서 제공하는 세마포어를 통해 구현할 수 있다.

## 3.3 세마포어

세마포어(Semaphore)는 내부적으로 공유자원의 개수로 초기화된 카운팅을 가지고 있고, 공유 자원을 빌려줄 때 마다 1씩 감소하고, 공유 자원이 반납될 때 마다 1씩 증가한다. 카운팅이 0이라면 공유 자원이 반납될 때 까지 대기한다.

세마포어의 카운터가 1 개인 경우 바이너리 세마포어(Binary semaphore), 두 개 이상인 경우 카운팅 세마포어(Counting semaphore)라고 한다.
바이너리 세마포어는 사실상 mutex와 같다.

## 3.4 스핀락과 다른 해결법

위와같은 해결법을 스핀락(spin-lock)이라 한다. 자원을 획득할 때 까지 바쁘게 while을 반복(spinning)하기 때문이다. 이외에는 조건변수를 사용하여 작업이 완료되면 다른 쓰레드를 깨우는 방식으로 구현한 '조건변수' 방식이나, 뮤텍스에 조건변수를 합친듯한 '모니터'를 이용한 해결방식도 있다.

세마포는 OS레벨에서 제공하는 방식이고, 모니터는 프로그래밍 언어 레벨에서 제공하는 동기화 도구이다. 세마포는 OS레벨의 비교적 저수준의 객체라고 볼 수 있다.

# 4. 데드락과 기아

두 프로세스가 서로 종료될 때까지 대기하는 프로그램을 실행한다고 생각해보자. 프로세스 A는 B가 종료될 때까지, 프로세스 B는 A가 종료될 때까지 작업을 하지 않기 때문에 프로그램은 어떤 동작도 하지 못할 것이다. 이처럼 **두 프로세스가 리소스를 점유하고 놓아주지 않거나, 어떠한 프로세스도 리소스를 점유하지 못하는 상태가 되어 프로그램이 멈추는 현상을 데드락(Deadlock)이라고 한다.** 운영체제도 결국 소프트웨어이기 때문에 데드락에 빠질 수 있다.

## 4.1 데드락에 관한 비유

데드락에 관한 유명한 비유가 있다. 철학자 5명이 식탁 가운데 음식을 두고 철학자들은 사색과 식사를 반복한다. 포크는 총 5개, 단 음식을 먹으려면 2개의 포크를 사용해야 한다. 즉, 동시에 음식을 먹을 수 있는 사람은 두 명뿐이다. 운이 좋으면 5명의 철학자들이 돌아가면서 사색과 식사를 이어갈 수 있다. 하지만 **모두가 포크를 하나씩 들고 식사를 하려하면 누구도 식사를 할 수 없는 상태**, 다시말해 데드락에 빠져 버린다. 이것이 바로 철학자들의 만찬 문제(Dining-Philosophers Problem)이다.

데드락은 다음 챕터에서 다룬다.

# References

[🦕 공룡책으로 정리하는 운영체제 Ch.6 (parksb.github.io) - 9판](https://parksb.github.io/article/10.html)

[운영체제 정리 🦖 ch06. CPU 스케줄링](https://aerocode.net/387?category=798030)
