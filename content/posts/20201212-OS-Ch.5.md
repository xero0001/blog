---
title: 🦕 OPERATING SYSTEM CONCEPTS - 5. CPU 스케줄링
description: 공룡책 정리하기
date: "2020-12-12S05"
tags: "운영체제"
---

운영체제가 어떤 프로세스를 프로세서에 할당할 것인가 정하는 프로세스 스케줄링(Process scheduling)에 대해 다루는 챕터다. FCFS, SJF, RR 등 다양한 프로세스 스케줄링에 대해 소개한다.

# 1. 기본 개념

프로세스는 CPU를 집중적으로 사용하는 경우 CPU burst를 하고, I/O를 집중적으로 사용하는 경우 I/O burst를 한다. CPU burst를 하던 프로세스가 I/O burst를 시작하는 경우 원래 프로세스를 처리하던 CPU에 ready 큐에 있던 다른 프로세스를 실행시킬 수 있다. ready 큐는 항상 FIFO 큐는 아님을 이해하자. 다양한 방식으로 구현될 수 있다.

## 1.1 선점과 비선점 스케줄링(Preemptive and Nonpreemptive Scheduling)

CPU 스케줄링은 다음 네가지 상황 하에 결정된다.

1. 프로세스가 running state에서 waiting state로 바뀔 때(I/O request)
2. 프로세스가 running state에서 ready state로 바뀔 때(인터럽트 발생시)
3. 프로세스가 waiting state에서 ready state로 바뀔 때(I/O 완료시)
4. 프로세스가 종료될 때

오직 1, 4 상황에서만 스케줄링이 일어나는 것을 비선점방식이라고 부른다. 비선점방식은 한 CPU에 프로세스가 할당되면 그 프로세스가 종료되거나 waiting state로 전환될 때 까지 놓아주지 않는다. 현대적인 OS에선 사용하지 않는 방식이다.

반대경우를 선점방식이라고 하는데, 작업이 끝나지 않아도 OS가 사용권을 회수할 수 있는 경우를 말한다. 이 때는 race condition이 발생할 수 있다. 예를들어 두 프로세스가 데이터를 공유하고 있는 경우, 하나의 프로세스가 데이터를 업데이트하는 도중, 다른 프로세스가 실행되어버리면 state의 inconsistent가 발생한다.

## 1.2 디스패쳐(Dispatcher)

디스패쳐는 CPU 스케줄러가 선택한 프로세스를 CPU에 할당하는 역할을 하며, 이를 디스패치(dispatch)라고 한다. 다음 기능을 포함한다.

- 한 프로세스의 context를 다른 프로세스의 context로 스위칭
- 유저 모드로 스위칭
- 이전에 실행하던 지점으로 재개하기 위해 유저 프로그램의 특정 부분으로 점프

역할을 보면 context switch를 할때마다 실행되는 것임을 알 수 있다.

# 2. 스케줄링 기준

운영체제가 레디 큐(Ready queue)에 있는 프로세스들 중에서 어떤 프로세스를 디스패치할 것인가 정하는 것이 프로세스 스케줄링(Process scheduling)이다.

스케줄링 알고리즘에는 대표적으로

- FCFS(First-Come, First-Served)
- SJF(Shortest Job First)
- SRF(Shortest Remaining Time First)
- RR(Round Robin)

네 가지 방식이 있고, 어떤 것을 기준으로 어떤 알고리즘을 사용하는가에 대해 평가할 때는

- 수행 시간(Burst time)
- CPU 사용량(CPU utilization)
- 단위 시간 당 끝마친 프로세스의 수(Throughput)
- 하나의 프로세스가 레디 큐에서 대기한 시간부터 작업을 마칠 때까지 걸리는 시간(Turnaround time)
- 프로세스가 레디 큐에서 대기한 시간(Wating time)
- 프로세스가 처음으로 CPU를 할당받기까지 걸린 시간(Response time)

을 기준으로 한다.

선점(Preemptive) 방식과 비선점(Non-Preemptive) 방식으로 나뉜다. 선점 스케줄링은 운영체제가 강제로 프로세스의 사용권을 통제하는 방식이고, 비선점 스케줄링은 프로세스가 스스로 다음 프로세스에게 자리를 넘겨주는 방식이다. 즉, 선점 스케줄링 방식에서는 CPU에 프로세스가 할당되어 있을 때도 운영체제가 개입해 다른 프로세스에게 CPU를 할당할 수 있다.

## 2.1 FCFS (First-Come, First-Served)

- 먼저 들어온 프로세스를 먼저 프로세서에 할당하는 방식이다.
- Queue의 FIFO(First-In First-Out)와 동일하다.
- 구현이 쉬워서 간단한 시스템에 자주 사용된다.
- 프로세스 처리 순서에 따라 성능이 크게 달라질 수 있다.
- 수행 시간이 큰 프로세스가 먼저 들어오면 그 뒤에 들어온 프로세스들이 불필요하게 오랜 시간을 기다리게 되는 콘보이 효과(Convoy effect)가 발생한다.
- 먼저 온 프로세스가 끝날 때까지 운영체제가 개입하지 않는 비선점 스케줄링 방식이다.

| Process | Burst time | Response time | Turnaround time | Waiting time |
| ------- | ---------- | ------------- | --------------- | ------------ |
| P1      | 9          | 0             | 9               | 0            |
| P2      | 1          | 9             | 10              | 9            |
| P3      | 1          | 10            | 11              | 10           |

```
+----+----+----+----+----+----+----+----+----+----+----+
|                     P1                     | P2 | P3 |
+----+----+----+----+----+----+----+----+----+----+----+
0                                            9    10   11
```

```math
\text{Average wating time} = {0 + 9 + 10 \over 3} = 6.33
```

P1, P2, P3 프로세스가 들어온 순서대로 할당됐다. P2, P3는 수행 시간이 짧음에도 P1이 끝날 때까지 기다리게 되어 평균 대기 시간이 늘어났다.

## 2.2 SJF (Shortest Job First)

- 프로세스의 수행 시간이 짧은 순서에 따라 프로세서에 할당한다.
- FCFS에서 발생하는 콘보이 효과를 해결할 수 있다.
- 최적 알고리즘이지만 수행 시간을 정확히 알 수 없다. (앞서 처리한 프로세스들의 기록을 보고 추측한다.)
- 버스트 시간이 큰 프로세스는 계속 뒤로 밀려나는 기아(Starvation)가 발생한다.
- 버스트 시간이 짧은 프로세스가 끝날 때까지 운영체제가 개입하지 않는 **비선점 스케줄링 방식**이다.

| Process | Burst time | Response time | Turnaround time | Waiting time |
| ------- | ---------- | ------------- | --------------- | ------------ |
| P1      | 6          | 3             | 9               | 3            |
| P2      | 8          | 16            | 24              | 16           |
| P3      | 7          | 9             | 16              | 9            |
| P4      | 3          | 0             | 3               | 0            |

```
+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|      P4      |              P1             |                P3                |                   P2                  |
+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
0              3                             9                                  16                                      24
```

```math
\text{Average wating time} = {3 + 16 + 9 + 0 \over 4} = 7
```

프로세스의 수행 시간을 정확히 예측했다는 가정하에, 수행 시간이 짧은 순서대로 프로세서에 할당됐다.

## 2.3 SRF (Shortest Remaining Time First)

- 프로세스의 남은 수행 시간이 짧은 순서에 따라 프로세서에 할당한다.
- SJF에서 발생하는 기아 문제를 해결할 수 있다.
- 수행 중 다른 프로세스보다 남은 수행 시간이 적어지면 운영체제가 개입해 자리를 바꾸는 **선점 스케줄링 방식**이다.

| Process | Arrival time | Burst time | Response time | Turnaround time | Waiting time |
| ------- | ------------ | ---------- | ------------- | --------------- | ------------ |
| P1      | 0            | 8          | 0             | 17              | 9            |
| P2      | 1            | 4          | 1             | 5               | 0            |
| P3      | 2            | 9          | 17            | 24              | 15           |
| P4      | 3            | 5          | 5             | 7               | 2            |

```
+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
| P1 |         P2        |           P4           |                P1                |                     P3                     |
+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
0    1                   5                        10                                 17                                           26
```

```math
\text{Average wating time} = {9 + 0 + 15 + 2 \over 4} = 26
```

P1이 수행되던 중, 1ms에 P2가 들어왔다. 이때 P1의 남은 수행 시간은 7ms이고, P2의 남은 수행 시간은 4ms이기 때문에 운영체제가 개입해 P1의 수행을 중단하고 P2를 프로세서에 할당한다. P2가 프로세서에 할당된 사이, 2ms에 P3가 들어왔으나 P2의 남은 수행 시간은 3ms이고, P3의 남은 수행 시간은 9ms이기 때문에 프로세서는 P2를 계속 수행한다. 이어서 3ms일 때 P4가 들어왔지만 P2의 남은 수행 시간은 2ms이고, P4의 남은 수행 시간은 5ms이기 때문에 여전히 P2가 수행된다. 이후에도 같은 방식으로 프로세스의 작업이 끝나거나 새로운 프로세스가 들어올 때마다 남은 수행 시간을 비교해 자리를 바꿔준다.

## 2.4 RR (Round Robin)

- 일정 시간 할당량(Time quantum) 단위로 여러 프로세스를 번갈아가며 프로세서에 할당한다.
- 시스템의 time-sharing과 같은 방식이다.
- 반응성이 좋다.
- 주로 우선순위 스케줄링(Priority scheduling)과 결합해 프로세스의 시간 할당량을 조절하는 방식으로 활용한다.
- 시간 할당량에 따라 운영체제가 계속 개입하는 **선점 스케줄링 방식**이다.

| Process | Burst time | Response time | Turnaround time | Waiting time |
| ------- | ---------- | ------------- | --------------- | ------------ |
| P1      | 15         | 0             | 19              | 4            |
| P2      | 2          | 3             | 5               | 3            |
| P3      | 2          | 5             | 7               | 5            |

```
Time quantum = 3ms

+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
|      P1      |    P2   |    P3   |      P1      |      P1      |      P1      |      P1      |
+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
0              3         5         7              10             13             16             19
```

```math
\text{Average wating time} = {4 + 3 + 5 \over 3} = 4
```

모든 프로세스들이 동일하게 3ms씩 프로세스에 할당된다. P2와 P3의 경우 수행 시간이 2ms이기 때문에 할당된 3ms를 모두 사용하지 않았다.

## 2.5 Priority Scheduling

- 특정 기준으로 프로세스에게 우선순위를 부여해 우선순위에 따라 프로세서에 할당한다.
- 프로세스를 에이징(Aging)해서 오래 대기한 프로세스의 우선순위를 높이는 방식으로 사용된다.
- SRF의 경우 남은 수행 시간을 기준으로 우선순위를 부여한다고 할 수 있다.
- 다른 스케줄링 알고리즘과 결합해 사용할 수 있으므로 **선점, 비선점 모두 가능**하다.

| Process | Priority | Burst time | Response time | Turnaround time | Waiting time |
| ------- | -------- | ---------- | ------------- | --------------- | ------------ |
| P1      | 3        | 5          | 4             | 9               | 4            |
| P2      | 1        | 1          | 0             | 1               | 0            |
| P3      | 4        | 2          | 9             | 11              | 9            |
| P4      | 5        | 1          | 11            | 12              | 11           |
| P5      | 2        | 3          | 1             | 4               | 1            |

```
+----+----+----+----+----+----+----+----+----+----+----+----+
| P2 |      P5      |           P1           |    P3   | P4 |
+----+----+----+----+----+----+----+----+----+----+----+----+
0    1              4                        9         11   12
```

```math
\text{Average wating time} = {4 + 0 + 9 + 11 + 1 \over 5} = 5
```

우선순위에 따라 프로세스가 할당되었다. 사용자가 자주 사용하는 프로세스의 우선순위를 높게 부여하는 식으로 기준을 만들 수 있다. 다만 특정 프로세스의 우선 순위가 계속 밀려 기아가 발생할 수 있으므로, 시간이 지날 때마다 프로세스의 나이를 증가시켜 오래 대기한 프로세스의 우선순위를 높여주는 조치가 필요하다.

# References

[🦕 공룡책으로 정리하는 운영체제 Ch.5 (parksb.github.io) - 9판](https://parksb.github.io/article/9.html)

[운영체제 정리 🦖 ch05. CPU 스케줄링](https://aerocode.net/374?category=798030)
