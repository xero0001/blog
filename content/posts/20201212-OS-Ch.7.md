---
title: 🦕 OPERATING SYSTEM CONCEPTS - 7. 데드락
description: 공룡책 정리하기
date: "2020-12-12S07"
tags: "운영체제"
---

![Deadlock](deadlocktoon.jpg)

데드락은 프로세스가 리소스를 점유하고 놓아주지 않거나, 어떠한 프로세스도 리소스를 점유하지 못하는 상태가 되어 프로그램이 멈추는 현상을 말한다.

# 1. 시스템 모델

프로세스는 다음과 같은 흐름으로 리소스를 이용한다.

1. **Request:** 리소스를 요청한다. 만약 다른 프로세스가 리소스를 사용중이라서 리소스를 받을 수 없다면 대기한다.
2. **Use:** 프로세스는 리소스 위에서 수행된다.
3. **Release:** 프로세스가 리소스를 놓아준다.

Request와 Release는 시스템콜을 사용한다.

시스템 테이블에 자원의 상태를 기록한다.

# 2. 데드락의 특성

데드락은 다음 4가지 상황을 전부 만족해야 발생한다.

- **Mutual exclusion:** 여러 프로세스 중 하나만 critical section에 진입할 수 있을 때.
- **Hold and wait:** 프로세스 하나가 리소스를 잡고 있고, 다른 것은 대기중일 때.
- **No preemption:** OS가 작동중인 프로세스를 임의로 중단시킬 수 없을 때.
- **Circular wait:** 프로세스가 순환적으로 서로를 기다릴 때.

만약 위 조건 중 하나만 만족되지 않아도 데드락은 발생하지 않는다.

# 3. 자원 할당 그래프

프로세스 간의 관계를 그래프로 도식화해 보면 데드락이 발생할지 예상할 수 있다. 만약 **그래프에 사이클이 있다면 데드락 위험이 있다는 의미**가 된다.

사이클이 있다고 무조건 데드락이 발생한다는건 아니지만, 사이클이 없으면 데드락이 절대 발생하지 않는다.

# 4. 데드락 제어

데드락을 제어하는 데는 크게 두가지 방법이 있는데, 하나는 데드락을 방지하는 것이고, 또 다른 하나는 데드락을 피하는 것이다.

## 4.1 데드락 방지

데드락을 방지한다는 것은 **데드락 발생 조건 중 하나를 무너뜨림으로써 데드락이 발생하지 않도록 하는 것**이다.

- Mutual Exclusion: critical section problem을 해결하기 위해서는 이 조건을 만족해야 하므로, 공유되는 자원이 있다면 이 조건을 만족시킬 수 밖에 없다.
- Hold and wait: 한 프로세스가 실행되기 전 모든 자원을 할당시키고, 이후에는 다른 프로세스가 자원을 요구하도록 한다. starvation 문제가 생길 수 있다.
- No preemption: 리소스를 점유하고 있는 프로세스가 다른 리소스를 요청했을 때 즉시 리소스를 사용할 수 없다면 점유하고 있던 리소스를 release한다.
- Circular wait: 같은 자원의 종류와 같은 갯수를 요구하는 프로세스끼리는 우선순위를 지정해준다.

데드락을 방지하는 것은 장치 효율과 시스템 성능을 떨어트리는 문제가 있다.

## 4.2 데드락 회피

데드락을 피하는 것은 **데드락이 발생할 것 같을 때는 아예 리소스를 할당하지 않는 것**이다. 여기서는 시스템이 unsafe 상태가 되지 않도록 해야 하며, 만약 unsafe 상태가 되면 최대한 빨리 safe 상태로 복구한다. 데드락 가능성은 포인터로 자원 할당 그래프(Resource allocation graph)를 구현해 판단한다. 만약 리소스 타입이 여러 개라면 banker's algorithm을 사용한다.

### 4.2.1 안전상태

다음 정보들이 주어졌을 때 해당 요청들을 모두 이뤄줄 수 있다고 판단되는 상태를 안전상태라고 한다. 그리고 그 요청을 이루는 순서를 안전순서라고 한다.

- Available: 현재 시스템의 가용자원
- Allocation: 각 작업이 점유중인 자원 정보
- Max Need: 각 작업이 필요로하는 자원의 최대량
- Request: 각 작업이 현재 요청한 자원 정보

## 4.3 Banker's Algorithm

banker's algorithm은 Dijkstra가 고안한 데드락 회피 알고리즘이다. 이는 프로세스가 리소스를 요청할 때마다 수행되며, 만약 리소스를 할당했을 때 데드락이 발생하는지 시뮬레이션한다.

안전순서가 있는지를 검사한 뒤에 수락여부를 결정하는데, 각 작업이 필요한 모든 자원을 한꺼번에 요청함을 가정하는 방식이다.

각 자원이 1개인 경우는 사이클검사만으로 충분하지만, 각 자원이 N개인 경우는 banker's algorithm을 이용한다.

# 5. 데드락 회복

만약 시스템이 데드락을 방지하거나 회피하지 못했고, 데드락이 발생했다면 데드락으로부터 복구되어야 한다. 이때는 어떤 프로세스를 종료시킬지 정하는 것이 중요해진다. 여기에는 몇가지 판단 기준이 있다:

- 프로세스의 중요도
- 프로세스가 얼마나 오래 실행됐는가
- 얼마나 많은 리소스를 사용했는가
- 프로세스가 작업을 마치기 위해 얼마나 많은 리소스가 필요한가
- 프로세스가 종료되기 위해 얼마나 많은 리소스가 필요한가
- 프로세스가 batch인가 interactive한가

## 5.1 리소스 선점

데드락을 해결하기 위해 리소스 선점(Preemption) 방식을 사용할 때는 다음과 같은 이슈가 있다.

- Selecting a victim: 어떤 프로세스를 종료시킬 지 결정한다.
- Rollback: 데드락이 발생하기 전 상태로 되돌린다.
- Starvation: 계속 같은 프로세스가 victim이 될 수 있다. 이 경우 기아(Starvation) 문제가 발생한다.

# References

[🦕 공룡책으로 정리하는 운영체제 Ch.7 (parksb.github.io) - 9판](https://parksb.github.io/article/11.html)

[운영체제 정리 🦖 ch07. 교착상태](https://aerocode.net/388?category=798030)
