---
title: ☕ 개체지향프로그래밍 - 1. OOP의 특성
description: OOP에 관한 내용 정리
tags: "자바"
date: "2020-12-15S01"
---

Pope Kim님의 강의를 듣고 필요한 부분만 요약한 내용입니다. 배우면서 느낀점은, 컴파일러와 언어 구조는 프로그래머나 사용자의 abuse를 막기 위한 다양한 constraint와 안전장치가 있다는 점입니다. 이는 시스템의 안정성과 보안, 생산성 향상으로 이어지겠죠.

# OOP의 특성

보통 4가지 특성이 있다고하는데, 문헌에 따라 3대 특성 혹은 7대 개념이 있다고도 함.

## OOP의 3대 특성

- 캡슐화(encapsulation): 하나의 개체 안에 필요한 변수나 메소드를 하나로 묶는 것. 공개가 불필요한 정보를 은닉하는 역할도 있다.
- 상속(inheritance): 이미 존재하는 클래스에 기반해 확장된 클래스를 정의하는 개념이며, 클래스의 특성을 재활용할 수 있어 코드의 중복을 막는다.
- 다형성(polymorphism): 상속을 통해 기능을 확장하거나 변경하는것. 같은 함수이지만 클래스의 종류에 따라 다른 기능을 할 수 있게 한다. 어떤 함수가 실행될지는 실행 중에 결정되기 때문에 late binding에 해당한다. 오버라이딩의 개념이기도하다.

하나 더 추가하자면,

- 추상화(abstraction): 내부의 구체적인 작동방식에 구애받지 않고, 여러 클래스의 공통된 특성을 파악해 일반화된 개념만 남기는 것이 추상화이다. 예를 들어 스위치를 누르면 안의 전기가 어떻게 동작하여 전구의 불을 키는지 몰라도, 버튼과 전구와의 관계만을 남기는 것이다. 추상 클래스나 인터페이스를 통해 다형성을 갖게하기도 한다.

이외에도 다음과 같은 개념들이 있다.

- 연관(association): 실세계에서 개체들이 상호작용하는 모습과 관련된 개념. 어떤 개체가 제공하는 기능을 다른 개체가 이용하는 관계. 세부적으로 집합과 컴포지션으로 나누기도 함. 보통 컴포지션으로 퉁치기도 한다.
- 컴포지션(composition): 여러개의 컴포넌트를 조립해 새 개체를 만드는 방법. 부품 그 자체로는 의미가 없으나, 조립품이 소멸할 때 부품도 같이 소멸함. 예를 들며 자동차의 부품들.
- 집합(aggregation): 여러 개체를 모아 다른 개체를 만들지만, 별도로도 존재 가능. 조립품이 소멸해도 부품이 소멸되지 않음. 예를 들면 어떤 대학의 학생들.

# 상속

선생이라는 클래스와, 학생이라는 클래스가 있다면, 둘의 공통점은 '사람'이다. 이러한 공통점이라는 교집합을 부모 클래스로 두어 상속받도록 하면 중복된 코드를 제거할 수 있다.

```python
Person {
  -firstName: String
  -lastName: String
  --------
  +Person(String, String)
  +getFullName(): String
  +changeName(String, String)
}

Student {
  -major: Major
  --------
  +Student(String, String)
  +getMajorOrNull(): Major
  +setMajor(Major)
}

Teacher {
  -department: Department
  --------
  +Teacher(String, String, Department)
  +getDepartment(): Department
  +setDepartment(Department)
}
```

참고로 클래스의 생성자는 부모부터 실행되고 다음으로 자식의 생성자가 실행된다. 실행순서는 다음과같다.

1. 메모리에 개체 생성
2. 부모 생성자 호출
3. 자식 생성자 호출

참고로 그냥 'Person'이라는 인스턴스를 만들지 못하게 하기 위해선 Person을 추상 클래스로 선언하면 된다. 그러면 오직 Student와 Teacher 클래스만으로 인스턴스를 만들 수 있다.

## is-a 관계에서의 선언

학생이나 선생은 사람이다. 그렇기 때문에 다음과같은 선언이 가능하다.

```java
Person[] people = new Person[2];

people[0] = new Student("Leon", "Kim");
people[1] = (Person) new Teacher("Sad","Panda",Department.COMPUTER_SCIENCE);
```

사람은 학생이나 선생이 아니다. 그러므로 Student에 new Person을 하는것은 불가능하다.

이는 캐스팅을 통해 가능한 것이므로, 자식의 함수를 호출하는 것은 불가능해진다.

만약 명시적으로 캐스팅하는 경우 부모를 자식으로 캐스팅하는 것도 가능하다.

instanceOf를 사용하면 타입을 체크할 수 있다.

## 다중상속

다중상속은 왠만하면 하면 안된다.. 문제를 해결할 수는 있겠지만 말도 안되게 복잡해진다.

인터페이스로 해결하거나, 컴포지션으로 해결한다.

상속이 너무 깊어지면 관리하기 좋지 않으므로, 1~2단계까지만 한다.

# 상속 vs 컴포지션

상속에서 부모와 자식의 관계는 is-a 관계이다. 컴포지션의 관계는 has-a 관계라고 한다.

둘 다 재사용성을 위한 방법이기 때문에 상속으로 해결할 수 있는 많은 문제는 컴포지션으로도 해결가능하다. 그 반대도 가능하고.

둘 중 무엇이 무조건 낫다고 할 수는 없다. 그렇기 때문에 OO에서는 상속을 할것인지 컴포지션을 할것인지가 큰 결정사항중 하나이다.

간단한 가이드라인을 제시하자면, 실생활에서 개체들끼리의 관계를 기준으로 선택하는게 좋지만, 필요하면 어길 수 있다.

## 상속과 컴포지션을 선택하는 4가지 기준

둘다 재사용성에 집중하고 있기 때문에 가능/불가능 측면으로만 보면 둘 다 사용가능한 경우가 많다.

- 기계적 차이 때문에 하나를 골라야 할 때

  - 메모리 구조상 한쪽이 너무 복잡해 질 때

- 용도 때문에 상속을 고를 수 밖에 없을 때
  - ECS처럼 한번에 같은 동작을 처리하고 싶을땐 컴포지션
- 관리의 효율성을 생각할 때
  - 깊은 상속의 경우는 관리가 어려울 수 있다. 이 때 인터페이스나 다형성을 사용하면 문제를 조금 완화한다.
- 그 외 일반적인 상황
  - 상식적으로 처리하자.

## 엔티티 컴포넌트 시스템

아키텍쳐 패턴 중 하나. 코드 변경 없이 자유롭게 개체를 만들 수 있도록 하는 게 목적.

Unity에서 사용중이다.

# 다형성(Polymorphism)

다형성이란 어떤 개체가 다양한 형태로 변할 수 있는 능력이 있다는 것이다.

부모 개체에서 함수 시그내쳐(파라미터 리스트)를 선언하고, 자식 개체에서 그 함수를 다르게 구현하며 오버라이딩한다. 이후 늦은 바인딩(late binding)을 통해 런타임에 함수 구현을 결정할 수 있다.

```java
Animal dog = new Dog();
Animal cat = new Cat();
dog.shout();
cat.shout();
// 실행결과
멍멍
냥냥
```

메서드에 final을 사용하면 오버라이딩을 막을 수 있다.

클래스에 final을 사용하면 다른 클래스의 부모가 되지 못한다.

## 오버라이딩과 오버로딩

오버라이딩(overriding)은 상속시 동일한 함수를 다르게 구현하는 다형성의 필수 요소이며.

오버로딩(overloading)은 같은 함수의 이름을 갖지만 다른 파라미터를 받는 여러 함수를 함께 구현하는 방식이다.

참고로 자바에서는 오버라이딩 시 @Override 로 어노테이션을 추가할 수 있다.

## 다형성의 장점

캡슐화, 유지 보수성, 코드 작성 효율의 장점이 있다.

## 추상 클래스

```java
public abstract class Monster {
  ...
  public abstract int calculateDamage(Monster target);
}
```

이와같이 클래스와 메서드를 abstract로 선언하면 자식 클래스가 해당 메서드를 구현하도록 강요한다.

## 인터페이스

함수 시그내쳐를 인터페이스라고 부르기도 하지만, 여기서 말할 것은 그것이 아니다. 주로 C처럼 선언과 구현이 분리되어 있을 때, 선언부를 선언, 시그내쳐, 인터페이스라고 부르고, 구현부를 구현(implements)라고 부른다.

인터페이스는 순수한 추상 클래스와 같다.

구조체는 데이터만 모아두고,

클래스는 데이터와 동작을 모아둔 것이다.

순수 추상 클래스인 인터페이스는 구현을 제외한 동작의 시그내쳐만을 모아놓은 것이다.

어떤 상태도 없고, 동작의 구현도 없고, 동작의 시그내쳐만 있기 때문에 일반 클래스와는 약간 다른 규칙을 갖는다.

### 1. 부모 클래스에서 할 일

- class를 interface로
- 메서드는 언제나 public

```java
public abstract class LoggerBase {
  public abstract void log(String message);
}

// to

public interface ILoggable {
  void log(String message);
}
```

### 2. extends를 implements로 바꿈

- 추상 클래스를 상속받는것과 전혀 다르지 않음
- extneds와 implements 키워드를 따로 분리하지 않는 언어도 많음

```java
public final class ConsoleLogger extends LoggerBase {
  ...
}

public final class ConsoleLogger implements ILoggable {
  ...
}
```

접두사로 I를 붙이는것과 접미사로 -able로 붙이는건 코딩 표준.

### 다중상속과의 비교

구현부가 없기 때문에 중복된 시그내쳐가 있어도 문제가 발생하지 않는다.

### 구체클래스와의 비교

#### 구체 클래스

- 상태와 동작을 모두 포함
- 동작에 다양한 접근권한 부여 가능
- 이로부터 개체 생성 가능
- 다중 상속의 부모가 될 수 없음

#### 인터페이스

- 동작에 대한 설명만 포함
- 모든 동작은 public
- 이로부터 개체 생성 불가능
- 다중 상속의 부모가 될 수 있음

## 구현 vs 인터페이스

클래스간 의존성은 나쁜 것이 아니다. 의존성은 A는 B에 의존성이 없지만, B만 A에 의존성이 있는 경우를 말한다. 오히려 의존성이 높을수록 캡슐화가 잘되있으므로 좋은것.

나쁜것은 결합도(coupling). 모듈간 상호 의존성이 큰것이 나쁜것이다. A도 B에 의존성이 있고, B도 A에 의존성이 있는게 나쁜것.

결합도가 높으면 B를 변경할때 A의 내부도 변경해야 제대로 동작한다. 이러한 경우를 tight coupling이라하고, 반대는 loose coupling이라고 한다.

### 의존성 주입(dependency injection)

```java
public Robot(int initialHp, Head head) {
  this.hp = initialHp;
  this.head = head;
}

...

Head head = new Head(45);
Robot robot = new Robot(300, head);
```

이렇게 외부에서 클래스를 만들어 넣어주는 것을 의존성 주입이라고 한다.

줄여서 DI라고 주로 한다.

### 디커플링의 단점

디커플링은 유연성과 재사용성을 높인다.

그러나 나쁜점들도 있다.

1. 직관적이지 못하다.
2. 내부를 알아야 좋은 경우도 있다.

디커플링이 언제나 옳은 것은 아니다.

그것보다 협업 시 가장 중요한 목표는 `실수 예방`이다. 추상화가 될수록 직관성이 떨어진다.

### 실용적인 인터페이스 사용법

- 기본적으로 클래스를 사용
- 함수 포인터나 다형성 있는 다중상속이 필요한 경우
- 변화에 대비할 필요가 있다면 커플링을 줄이려는 목적으로 사용

시스템이 크지 않고, 내 라이브러리에 대한 의존성이 낮다면, 쉽게 변경을 일으켜도 좋기 때문에 인터페이스를 사용할 떄의 실익이 줄어듦.

이러한 경우가 아니라면 인터페이스를 사용하는 실익이 늘어난다. 인터페이스를 사용하면 미래의 변화에 좀 더 잘 대비된다.

### 함수형 인터페이스(Functional Interface)
