---
title: 🦕 OPERATING SYSTEM CONCEPTS - 9. 가상 메모리
description: 공룡책 정리하기
date: "2020-12-12S09"
tags: "운영체제"
published: false
---

# 논리적 메모리

프로그램의 크기가 남아있는 물리적 메모리보다 큰 경우에 과연 메모리에 어떤방식으로 로드해야할까?

## 가상 메모리

이를 해결하기 위해 전체 중 사용할 부분만 로딩하는 것이다. 프로그램이 필요한 전체 메모리를 논리적 메모리로 바라보고, 이 중 실행에 필요한 부분만 물리적 메모리에 옮겨다 놓는 방식이다.

![Physical Memory](os/physicalmemory.jpg)

이로써 프로그램의 관점(논리적 메모리)과 램의 관점(물리적 메모리)으로 분리할 수 있다. 또한 물리적 메모리부터 큰 프로그램을 실행할 수도 있다.

# 페이지 부재(Page-Fault)

만약 프로세스가 로딩되지 않은 페이지를 요구하는 경우, 이를 페이지 부재라고 하며, OS에 이 페이지를 로딩하도록 요청하는 것이 Demand Paging이다.

Demand Paging이 발생하면 디스크 작업으로 프로세스가 잠깐 정지한다. 그러나 이는 프로세스의 지역 참조성 덕분에 완화된다. Demand Paging은 매우 비싼 작업이다.

## Demand Paging의 종류

- 일반 Demand Paging: 필요해질 것 같은 페이지도 미리 로딩
- 순수 Demand Paging: 지금 필요한 것만 로딩

순수 Demand Paging은 바로 첫 실행부터 페이지 부재가 발생한다.

# 페이지 교체

새 페이지를 로딩할 Free Frame이 부족한 경우, 빈 프레임을 확보하기 위해 다음과 같은 전략을 취한다.

1. 다른 프로세스 종료 - 효율이 낮다
2. 다른 프로세스를 일시정지하고 백업(스왑 아웃) - 멀티 프로그래밍 정도가 매우 높을 때 최적
3. 해당 프로세스가 사용하고 있던 페이지를 교체 - 가장 일반적인 방법

## 페이지 교체 과정

![Page Replacement](os/pagereplacement.jpg)

1. 희생된 프레임의 변경점을 저장하기 위해 디스크에 쓴다.
2. 페이지 테이블에서 엔트리를 무효(i)로 변경.
3. 새 페이지를 읽어 희생된 프레임에 적는다.
4. 페이지를 불러오면 엔트리를 유효(v)로 변경한다.

## 개선된 과정

1번과 3번 과정에서 페이지 교체시 디스크 연산이 2번이나 발생하므로 비효율적이다. 프로세스가 그동안 기다려야 하기 때문.

이 때 변경된 적이 없는 프레임을 굳이 디스크에 적지 않아 1번을 스킵할 수 있다. 이는 페이지 테이블에 Modify-Bit 혹은 Dirty-Bit를 추가하여 관리한다.

# 페이지 교체 알고리즘

자주 사용되고, 가까운 미래에 자주 사용될 페이지는 희생되지 않도록 해야한다.

## FIFO 페이지 교체

## Optimal 페이지 교체

## LRU 페이지 교체

## LRU 근사 페이지 교체

## 계수 기반 페이지 교체

# 프레임 할당 정책 기준

## 최소 프레임의 수

## 프레임 개수 알고리즘

## 프레임 선점 여부

## 메모리 접근 시간

# 쓰레싱

# References

[운영체제 정리 🦖 ch09. 메모리 관리 전략](https://aerocode.net/390?category=798030)
